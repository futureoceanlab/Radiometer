/*   MIT Future Ocean Lab  &&  WHOI Deep Submergence Lab
--------------------------------------------------------------------------------
 Project:       FOL Radiometer
 Version:       Beebe
 Design:        RAD_Teensy
 Substrate:     Teensy 3.6
--------------------------------------------------------------------------------
 Module:        RAD_Teensy
 Filename:      RAD_Teensy.iso
 Created:       26/10/2019
 Author:        Allan Adams <awa@mit.edu>
--------------------------------------------------------------------------------
 Description:   RAD_Teensy is a Teensy 3.6 executable that operates the FOL/WHOI 
                Radiometer.  Its key responsibilities are:
 
 1. Capture & timestamp raw photon counts at 1-40kHz from the Hamamatsu sensor
    via 1GHz Cmod A7 Front End over Ports C and D, plus I2C & SPI sensor data
 2. Store data to non-volatile storage (SD card)
 3. Control filter cassette stepper motors (depricated for now) 
 4. Provide serial interface for control and heartbeat
 5. Don't fuck up
 
 In a little more detail.....

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
   A. The Hamamatsu & Xilinx front end:

 The FOL/DSL Radiometer is designed to count solar photons throughout the 
 first 800m of the open ocean (and bioluminescent photons much deeper).  
 
 The heart of the Radiometer is an array of geiger-mode photo-diodes capable of 
 resolving individual photon hits precisely and reliably. The Hamamatsu sensor,
 C13366-1350GD, outputs digital signals over SMB of duration 20ns and amplitude 
 ~3.7V. More precisely, there is a 40% chance (quantum efficiency 0.4) that any 
 single photon hitting the sensor will trigger a geiger-mode voltage spike of 
 Raleigh-ish form (a sudden rise and a gradual fall-off) out of the raw sensor.  
 The Hamamatsu module feeds this raw signal to a fast comparator which filters 
 this complex pulse into a clean square pulse about 20ns wide with rise and 
 fall times of under 2ns.  We can thus measure the incident photon flux by 
 counting pulses in the output of the comparator and multitplying by 2.5 to 
 account for the missed 60% of photons.

 Two effects limit the linearity of this signal.  First, as with any geiger-
 mode device, there is an irreducible dark noise due to spontaneous 
 excitationt of the high-gain sensor.  On this device that dark rate is about 
 1000 counts per second (1k cps), corresponding to about 2,500 would-be photons 
 per second (2.5k pps).  Empirically, this noise floor is extremely stable: on
 the two devices tested in our lab, the mean dark count was about 990 cps 
 with a standard deviation of about 40cps.  That  means we can meaningfully 
 infer photon flux from comparator counts down to around 40cps ~ 100 pps.

 The second failure of linearity arises at the high-luminosity regime, and is 
 considerably more problematic.  Suppose a second photon hits an independent 
 pixel on our sensor while the output of the first photon is still high.  The 
 output of the spad-array is the sum of the voltages generated by each pixel, 
 so the input to the coparator now  sees a  signal that is up to twice as 
 high and lasts up to twice as long as that produced by a single photon.  
 Correspondingly, the digital output from the comparator is a pulse that lasts
 up to twice as long, but with the same height.  If we simply count pulses, 
 then, that second photon is lost, leading to a departure from linearity that 
 grows rapidly as the typical photon arrival time decreases: as we ramp up 
 the incident photon flux, such photon "collisions" become more and more 
 common and the nuber of pulses lags further and further behind the true flux. 
 This effect starts to become important around 1M cps and O(15%) by 10M cps.
 At sufficiently high flux (~25M cps), adding another photon is more likely 
 to create a collision than a new pulse -- *increasing* the incident flux
 thus actually *decreases* the number of pulses coming out of the comparator. 
 Eventually the sensor fully saturates (~100M cps), with all pixels constantly 
 triggered and the comparator permanently high.

 On paper, that's annoying: the map between pulse count and infered photon 
 flux is doubly-valued, meaning we need to be careful to stay (well) within
 the almost-linear low-flux regime to be able to reliably infer the incident 
 fluxes. In the ocean, unfortuantely, that's just not possible: thanks to 
 all sorts of optical "noise" in the ocean (I'm looking at you, biolumin-
 escent squid) it's easy for the incident flux to pop over the maximum of 
 that curve and ruin any chance we have of nailing down the ambient flux.

 The answer is inescapable: it's not enough to just count pulses, we need  
 the duration of the pulses too. More generously, we need a good coordinate 
 near the maximum of the count curve.  This turns out to be non-trivial. 

 The approach we have taken is somewhat brute-force: rather than detect 
 rising edges in the comparator output, we sample the comparator at very 
 high frequency (1 GHz ~ 1 / ns), allowing us to both count pulses (which 
 provides a good coordinate in the linear regimes at both high and low 
 luminosity) as well as the fraction of the time that the output is high. 
 Fortunately the precise timing of individual collisions doesn't matter, 
 just the statistics, which makes the data problem easy enough to handle 
 with a small FPGA (doing the high-speed sampleing and counting) and 
 microcontroller (sampling the FPGA counts at low speed and storing to
 memory).  Concretetly, we use:
 
    * a Cmod A7 breakout for the Xilinx Artix-7 FPGA running at 250MHz 
      and sampling the comparator output via 2- or 4-bit SERDES inputs, 
      sampling that datastream to count pulses and time spent high, then
      storing the results in fast counters whose values it outputs over
      16-bit bus (GPIO pins) at 1 to 40 kHz to:
      
    * a Teensy 3.6 running at 240MHz that reads the two 16-bit data
      streams into a circular FIFO buffer which is subsequently written 
      to SD in the background.  The Teensy also handles sensors, Serial 
      comms, filter cassette motors, and general system control.

 The upshot is that we can infer from these two data streams (pulses, 
 fraction high) the incident photon flux to within a few percent or 
 better over fluxes ranging  from ~50 cps to ~50M cps, or six decades 
 of dynamic range.  That's pretty good.

 
 Before getting into the Teensy code, let's review the Cmod's interface.
 The Cmod has the folloiwing pins wired to the Teensy:
      -- in
    DATA_OUT[16]   Cmod-->Teensy   16-bit data bus (8 Port C, 8  Port D)
    PING_OUT       Cmod-->Teensy   Falling edge == new data available
      -- out
    DTOG_IN        Teensy-->Cmod   H: Data = Pulses;  L: Data = Time High
    NS_SEL_IN[3]   Teensy-->Cmod   Select sampling rate (1-40kHz)


 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   B.  Data Rates:

 The Cmod is sending two 16-bit samples with every ping.  Pings arrive with a 
 frequency of 1, 2, 4, 8, 10, 16, 25, 40 kHz (user selected).  Each ping is 
 stored along with the elapsed time since previous ping (2B) plus a 2B tag 
 [0xFD00] for a total of 8B per ping.  That gives the following data rates:
       kHz    kB/s     MB/hr     GB/day
       1         8      29        0.7
       2        16      58        1.5
       4        32     115        3
       8        64     230        6
       10       80     288        7
       16      128     460       11
       25      200     720       17
       40      320    1150       27
 Note that this does not include any additional payload (sensor data and UTC 
 recorded a few times per second) so this is a minor undercount by < 1%.  Said 
 more succinctly, the rates of interest lie within these ranges:

    8 to 320 kB/s      29 to 1150 MB/hr     0.7 to 27 GB/day 

 We could, of course, sample faster if there's a scientific reason to do so.
 The fundamental speed limitation here is how precisely we can do the sampling
 timing, but pushing up to 64kHz should be doable.  
 
 By default we'll sample at 1kHz, giving us a default data rate of about 
 
       8 KB/s            29 MB/hr          0.7 GB/day
 
 In  the scope of things, that's a leisurely data rate for an SD card -- the 
 SD interface we're using can handle 18MB/s; we are well within envelope! That 
 said, the SD interface presents some latency challenges for memory-limited MCUs, 
 so we do have work to do.  To start, SD writes happen in large blocksizes -- 
 strictly in multiples of 512b, but usually in much larger chunks, with RUs of 
 16KiB, 32KiB, or even larger.  To avoid SD interface latencies slowing
 things down, we store data into a large ring buffer, writing RUs to disk as
 soon as enough data are stored. 

 The size of the RingBuffer is constrained by several things:
      Data rates can be up to 320kB/s
      SD Latency can be up to 500ms
      T3.6 has 256kB RAM
      RU size = 16KiB
  We skin this cat with a RingBuffer of 12*16kB = 6*32kB = 192kB, leaving 64kB 
  free for program and SD libraries to do their thing while providing between 
  1s and 32s of latency buffer. If that's not enough, we have other problems.



 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

  C.  Sensors:
 
 On top of the counting photons, we need to keep track of which way the system
 is pointing.  To that end we have a Tilt sensor accessible via SPI.  We can be 
 pretty casual about precisely when we query, as the tilt should not be changing 
 all that fast -- we'll query at 1Hz and record the tilt with the heartbeat.

 We also have a handful of sensors accessible over I2C (T, P, ...).  Again, 
 speed is not of the essence, and we can query  them at our leisure.
 

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   D.  Power and Statup / Shutdown Sequences:
 
 A note on power. The main PCB (Teensy, Cmod, etc) operate on a nominal 5V bus,
 but the Hamamatsu needs stable +5 and -5 rails.  Meanwhile the system will be
 fed with anything between 9 and 36V, with no guarantee that noise will be low.
 We handle these conversions with a set of three LMR12020's, an extremely high-
 efficiency (>95%) switching-mode buck chipset, producing 5V, 5.5V, and -5.5V. 
 The 5V feeds the main Cmod/Teensy board, while the +/-5.5V feed a pair of LDOs 
 to generate very low noise +/-5V rails for the Hamamatsu. This brings our 
 overall system efficiency down to about 90%.  

 To provide power, the radiometer carries four 3.7V 18650 cells internally and 
 is able to accept 9-36V over the SubConn bulkhead.  The load switches from one
 to the other automatically as power is plugged in etc via a small power board, 
 allowing us to keep the system running from the lab to the vehicle -- helpful
 when running in untethered mode.

 Startup is delicate.  The FPGA cannott accept voltage on its pins while it's 
 powered down, so we must turn it on first before turning on anything else --  
 the Teensy, the Hamamatsu, etc.  Ditto  on powerdown. To deal with this, both
 the Teensy and the Hamamatsu draw power from independent load switches. Once 
 the Cmod is ready it enables the Teensy load switch;  when the Teensy is ready 
 it enables the Hamamatsu load switch.  

 Shutting down is more complex.  The shutdown is initiated by shorting two pins 
 on the connector.  This (a) pulls a pin low on the Teensy and (b) gives a 10s
 time window for everything to shutdown gracefully.  The Teensy then terminates
 its loops, saves files, disables the Hamamatsu load switch,  and then shuts 
 itself down.  When the powerbus hits the end of the grace period, the bus is 
 pulled low, shutting  down the Cmod gracefully.
 
 Here's a short rundown of the voltage  and power demands of each  device:

    Device          Vin     Amax      Atyp      Wmax      Wtyp
                        V    mA        mA        mW        mW
    Hamamatsu       +5      1000      200       5000      1000
                    -5        60       40        300       200      
    Cmod A7         +5       200       40       1000       200
    Teensy          +5       240      120       1200       600
    Motherboard     +5       100       40        500       200
----------------------------------------------------------------------
    Total                   1600      440       8000      2200

 Total power draw should thus hover somewhere around 2.2W, with bursts up to 
 perhaps 6W during startup, shutdown, or acts of Cthulu.
 
 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

 E.  Formatting and Protocols
 
 Metadata File Header Format  (ASCII):
 "Future Ocean Lab Radiometer Data File \r\n"
 "Software Version: FOL_RAD_VV"
 " .....\r\n"
 "Data Rate: SAMPLES_PER_SEC  \r\n"
 "Data Block Size: 4096  \r\n"
 "Data Format: 0xFDFD [2B] Microseconds [2B] Pulse Count [2B]  TimeHi [2B] \r\n"
 "Data Header Size: 32B  \r\n"
 "Data Header Format: \"@@...(18 times)...@@\" EpochTime[4B] \
                                  NanoSeconds[4B] Tilt[6B] \r\n"
 " .....\r\n"
 "CRUISE NAME, SHIP NAME, etc \r\n"
 "YYYY:MM:DD HH:MM:SS \r\n"
 
 
 Data Chunk Header Format (binary):
 "@@...(18 times)...@@" EpochTimeUTC[4B] NanoSeconds[4B] Tilt[6B]
 32 Bytes [= 18+14]
 
 Data Packet Format [8B]:
   [2B] 0xFC00
   [2B] uint16_t time since last ping in usec
   [2B] uint16_t Pulses
   [2B] uint16_t TimeHi

 Heartbeat Format [16B]:
   [2B] 0xFD00
   [2B] uint16_t X_Tilt
   [4B] uint32_t UTC Seconds
   [2B] 0xFE00
   [2B] uint16_t Y_Tilt
   [4B] uint32_t UTC Microseconds
 
 Heartbeat Message Format
 â€œRAD.VV yyyy:mm:dd  hh:mm:ssZ DDDDDDDDDD HHHHH PPPPP RRRRR \r\n"
 
 
 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

 F. Coding
 
 For the most part this is a pretty straightforward coding problem, with two
 caveats.  First, there are multiple timing-critical processes that need to 
 play nicely with each  other:
 
    1. Ping --> Read and store data immediately into RingBuffer
    2. Write logged data to SD
    3. Read from I2C  & SPI  sensors
    4. Serial Heartbeat and CLI
        Startup choice: Ns or Download? with timeout

 Second, there are multiple resources with potential race conditoins, notably:
 
    1. RingBuffer:  
      Write: Ping_ISR
      Read: SD Storage (main loop)

    2. Heartbeat Data (last second)
      LastSec_uSecs  = 0,      //
      LastSec_TimeHi = 0,      //
      LastSec_Pulses = 0;      // 
      New_Tilt[2];              // Heartbeat queries Tilt and stores it here

    2. Timing Semaphores


int                 CurrentFile    = 0;      // 
size_t              RUs_Written    = 0;      //
char                CLI_cmd[CLI_CMD_MAX_CHARS]; //

MAKE_RING_BUFFER(TeensyRing, size_Ring);          // 



elapsedMillis       Heartbeat_MilliClock;    // for ms since last Heartbeat 
volatile uint32_t   LastSec_uSecs  = 0,      //
                    LastSec_TimeHi = 0,      //
                    LastSec_Pulses = 0;      // 
volatile uint16_t   New_Tilt[2];              // Heartbeat queries Tilt and stores it here




volatile bool     fHeartbeat    = FALSE;   //
volatile bool     fPowerDownNow = FALSE;   //
volatile bool     fStopCount    = TRUE;    //
volatile bool     fHandlePings  = FALSE;   //  In place of dettachInterrupt, set to false




      
 
 To ensure we never miss a ping, we handle the data reads via a ping-
 triggered interrupt routine. To avoid any race condition over the buffer, 
 we place all writes-to-buffer into the same interrupt routine, and wrap  
 all flag-raising and -lowering with interrupt disables.  Reads from 
 the buffer and writes to the SD are then handled in the main loop with a
 simple semaphore to avoid races. [Note: we use an SD library that handles 
 interruption gracefully.]  Sensor reads and Serial CLI are also handled in 
 the main loop, with Sensor data stored in a global "payload" container 
 that's flagged for storage in the buffer during the next interupt.
 
 
  The job of this code is thus to:

    0. Setup and Initialization
    
      A. Setup GPIO & comms channels
  
      B. Build filestructure: 
        i. Preallocate SD files: 
           1 hour at max 32kHz data rate = 691 MB
           ==> Filesize = 1GB
           Preallocate array of 24 files
        ii. Write global headers  (first 16kB = header)
       
      C. Build ring buffers, initialize related variables

      D. Initiate Interrupt routine PING_ISR waiting on PING_IN
 
    1. PING_ISR: respond to ping by reading data and storing to RingBuffer
    
          Record new ping time
          Read 16-bit bus (8 in PortC, 8 in PortD) into local buffer
          Set Dtog Low, wait a few cycles
          Read 16-bit bus into local buffer
          Set Dtog High
          Write 2B us-since-last-ping into local buffer
            LocalBuffer [8B]:
               2B 0xFC
               2B us since last
               2B Pulses
               2B TimeHi
          Write local buffer into RingBuffer
          Decriment Ping_Count
          If 1s worth of Pings have gone by, add UTC &  Tilt to local buffer:
            UTC_Buffer: [16B]
               2B ASCII 0xFD
               4B UTC Seconds
               2B X_incl
               2B ASCII 0xFE
               4B UTC ElapsedMillis
               2B Y_incl
             Ping_Count = Ns;
             fGetNewTilt = TRUE;
           Write UTC_buffer into RingBuffer

    3. In main loop:
          If an RU of data are abaiable in the Ring buffer, write 1RU to SD
          If Sensor data are stale (.1-1Hz), update sensor data & store in 
            payload, taking care to prevent races over flags or pointers.
          Check for Serial IO and process expeditiously.


  
--------------------------------------------------------------------------------

  Dependencies: 
  
--------------------------------------------------------------------------------

  Issues:
  
------------------------------------------------------------------------------*/
#include "Rad_Teensy.h"
#include "PhotonEstimation.h"

/*         Things Left to do
 * 
 * A. USB Access to SD card  -- BUG!!!
 * 
 */




/*    Global Variables: Per Dive Data      
*/
char                ThisDive_CruiseName[]    = "WHOI OTZ Winter 2021";
char                ThisDive_ShipName[]      = "Catapult";
char                ThisDive_RadName[]       = "Radiometer \"Thompson\"";
char                ThisDive_Header_Msg[128] = "None";
uint8_t             ThisDive_SampleRateCode  =  0;    // 0...8
uint8_t             ThisDive_Duration_Hours  =  12;   //
uint8_t             ThisDive_NumFiles        =  N_FILES;    //



/*    Global Variables: Files and Buffers      
*/
FsFile              DataFile[N_FILES];       // 
FsFile              MetaFile;                // 
SdFs                sd;                      //

int                 CurrentFile    = 0;      // 
size_t              RUs_Written    = 0;      //
char                CLI_cmd[CLI_CMD_MAX_CHARS]; //

MAKE_RING_BUFFER(TeensyRing, size_Ring);          // 



/*    Gloabl Heartbeat Data     
*/
elapsedMillis       Heartbeat_MilliClock;    // for ms since last Heartbeat 
volatile uint32_t   LastSec_uSecs  = 0,      //
                    LastSec_TimeHi = 0,      //
                    LastSec_Pulses = 0,      // 
                    LastSec_Photons = 0;     //
volatile uint16_t   New_Tilt[2];              // Heartbeat queries Tilt and stores it here




/*    Gloabl Semaphores 
*/
volatile bool     fHeartbeat    = FALSE;   //
volatile bool     fPowerDownNow = FALSE;   //
volatile bool     fStopCount    = TRUE;    //
volatile bool     fHandlePings  = FALSE;   //  In place of dettachInterrupt, set to false


/*    Global Sensor Declarations
*/

// ADIS 16209 variables
// SPI1.PortSelect(...)
// ADIS16209 tiltsensor(pin_SPI1_CS,&SPI1); // Initialize tilt sensor
//ADIS16209 tiltsensor; // Initialize Tilt sensor

//TMP117 tempsensor; // Initalize Temperature sensor




/*    Read and Write Buffer wrapper functions    */

int Write_Ring_to_SD(void) {  // DONE
    if (DataFile[CurrentFile].write(TeensyRing._ring + TeensyRing.Tail, SIZE_RU) != SIZE_RU) {
        if (SERIAL_USB) {SERIAL_USB.println("file.write failed");}
        DataFile[CurrentFile].close();
        return(ERR_FILE_WRITE_FAILED);  // if file write fails, panic with -1
    }
    
    noInterrupts();
    TeensyRing.Count -= SIZE_RU;
    TeensyRing.Tail = (TeensyRing.Tail + SIZE_RU) % TeensyRing.Size;
    interrupts();
    
    if((++RUs_Written) * SIZE_RU >= File_Length) {
        DataFile[CurrentFile].close();
        if(++CurrentFile==N_FILES) return(ERR_OUT_OF_FILES);
        RUs_Written = 0;
    }
    return(0);
}

int Write_Data_to_Ring(uint8_t *data, uint8_t data_len) {  // DONE1
    /*------------------------------------------------------------------------------
     
     Write_Data_to_Ring  :  Inserts data into the Ring
     
     Along the way it checks for 2 edge cases:
     A. Ring Full
     ==> returns -1
     B. Data will wrap to or past the end of the Ring
     ==> splits data into chunks and writes across the divide.
     
     Note: assume Write_Data_to_Ring will run inside an interrupt routine
     and can't itself be interrupted
     
     ------------------------------------------------------------------------------*/
    static size_t next,nibbleA,nibbleB;
    
    if(TeensyRing.Count + data_len > TeensyRing.Size) { // Buffer Full!!
        return(ERR_BUFFER_FULL);
    } else { TeensyRing.Count += data_len; };
    // Once stored, count is  increased to reflect new data.
    
    // next is where head will point to after this write.
    next = TeensyRing.Head + data_len;
    
    if (next < TeensyRing.Size) { // if next is inside ring, just do it
        memcpy(TeensyRing._ring + TeensyRing.Head, data, data_len);
        TeensyRing.Head = next;
     } 
    else { // if next is outside ring, need to  
        // break up data chunk and write across modulo:
        // Data slots remaining at end of buffer
        nibbleA = TeensyRing.Size - TeensyRing.Head;
        // Length of leftover data to push into begining of buffer
        nibbleB = data_len - nibbleA;
        memcpy(TeensyRing._ring + TeensyRing.Head,  data,           nibbleA);
        if(nibbleB>0) memcpy(TeensyRing._ring, data + nibbleA, nibbleB);
        TeensyRing.Head = nibbleB;
     }
    return 0;  // return success to indicate successful push.
}

void Flush_Ring() {
  TeensyRing.Count = 0;
  TeensyRing.Head = 0;
  TeensyRing.Tail = 0;
}




/*      Buzzer Functions
 */

void BuzzerOn()  {digitalWrite(pin_Buzzer,HIGH);};

void BuzzerOff() {digitalWrite(pin_Buzzer,LOW);};

void BuzzerHamOpen() {
  elapsedMillis Buzzer_Millis;    // for ms since last Heartbeat 
  BuzzerOn();
  while(Buzzer_Millis<150) {};
  BuzzerOff();
  while(Buzzer_Millis<600) {};

  BuzzerOn();
  while(Buzzer_Millis<700) {};
  BuzzerOff();
  while(Buzzer_Millis<800) {};
  BuzzerOn();
  while(Buzzer_Millis<900) {};
  BuzzerOff();
  while(Buzzer_Millis<1000) {};
  BuzzerOn();
  while(Buzzer_Millis<1100) {};
  BuzzerOff();
  while(Buzzer_Millis<1200) {};

  BuzzerOn();
  while(Buzzer_Millis<1350) {};
  BuzzerOff();
  while(Buzzer_Millis<1800) {};
  
  BuzzerOn();
  while(Buzzer_Millis<1950) {};
  BuzzerOff();
  while(Buzzer_Millis<2400) {};

  BuzzerOn();
  while(Buzzer_Millis<2550) {};
  BuzzerOff();
  while(Buzzer_Millis<3000) {};
 }

void BuzzerDoom() {
  elapsedMillis Buzzer_Millis;    // for ms since last Heartbeat 
  for(int i=0;i<3;i++) {
    Buzzer_Millis=0;
    BuzzerOn();
    while(Buzzer_Millis<100) {};
    BuzzerOff();
    while(Buzzer_Millis<200) {};
    BuzzerOn();
    while(Buzzer_Millis<300) {};
    BuzzerOff();
    while(Buzzer_Millis<400) {};
    BuzzerOn();
    while(Buzzer_Millis<500) {};
    BuzzerOff();
    while(Buzzer_Millis<600) {};
    BuzzerOn();
    while(Buzzer_Millis<1000) {};
    BuzzerOff();
    while(Buzzer_Millis<1200) {};
  }
}

void BuzzerShutdown() {
  elapsedMillis Buzzer_Millis;    // for ms since last Heartbeat 
  for(int i=0;i<3;i++) {
    Buzzer_Millis=0;
    BuzzerOn();
    while(Buzzer_Millis<100) {};
    BuzzerOff();
    while(Buzzer_Millis<200) {};
    BuzzerOn();
    while(Buzzer_Millis<300) {};
    BuzzerOff();
    while(Buzzer_Millis<400) {};
    BuzzerOn();
    while(Buzzer_Millis<500) {};
    BuzzerOff();
    while(Buzzer_Millis<600) {};
    BuzzerOn();
    while(Buzzer_Millis<1000) {};
    BuzzerOff();
    while(Buzzer_Millis<1200) {};
  }
}

void BuzzerDot() {
  elapsedMillis Buzzer_Millis;    // for ms since last Heartbeat 
  BuzzerOn();
  while(Buzzer_Millis<100) {};
  BuzzerOff();
  while(Buzzer_Millis<150) {};
 }

void BuzzerDash() {
  elapsedMillis Buzzer_Millis;    // for ms since last Heartbeat 
  BuzzerOn();
  while(Buzzer_Millis<400) {};
  BuzzerOff();
  while(Buzzer_Millis<500) {};
 }





/*      Helper Functions
 */

void errorHalt(const char* msg) {
  SERIAL_USB.print("Error: ");
  if (SERIAL_USB)  {SERIAL_USB.println(msg);}
  if (sd.sdErrorCode()) {
    if (sd.sdErrorCode() == SD_CARD_ERROR_ACMD41) {
      if (SERIAL_USB) {SERIAL_USB.println("Try power cycling the SD card.");}
    }
    printSdErrorSymbol(&SERIAL_USB, sd.sdErrorCode());
    SERIAL_USB.print(", ErrorData: 0X");
    if (SERIAL_USB) {SERIAL_USB.println(sd.sdErrorData(), HEX);}
  }
  BuzzerDoom();  
  while (true) {} 
}

time_t getTeensy3Time() {
  return Teensy3Clock.get();
}


void dateTime(uint16_t* date, uint16_t* time) {
  // Return date using FS_DATE macro to format fields.
  *date = FS_DATE(year(), month(), day());

  // Return time using FS_TIME macro to format fields.
  *time = FS_TIME(hour(), minute(), second());
}

void sprintDateTime(char* sHTime,char* sFNTime) {
  TimeElements tm;
  breakTime(now(),tm);
  
  // "YYYY-MM-DD HH:MM:SS"
  sprintf(sHTime, "%.4u-%.2u-%.2u %.2u:%.2u:%.2u",1970+tm.Year,tm.Month, tm.Day,\
                                                       tm.Hour,tm.Minute,tm.Second);
  // "YYYY_MM_DD__HH_MM_SS"
  sprintf(sFNTime,"%.4u_%.2u_%.2u__%.2u_%.2u_%.2u",1970+tm.Year,tm.Month, tm.Day,\
                                                      tm.Hour,tm.Minute,tm.Second);
}

void Set_Ns(void) {
  digitalWrite(pin_NsSel[0],( (ThisDive_SampleRateCode >> 0)  & 0x01  ? HIGH : LOW));
  digitalWrite(pin_NsSel[1],( (ThisDive_SampleRateCode >> 1)  & 0x01  ? HIGH : LOW));
  digitalWrite(pin_NsSel[2],( (ThisDive_SampleRateCode >> 2)  & 0x01  ? HIGH : LOW));
}






/*      SETUP AND INITIALIZATION FUNCTIONS
 */

void setup_GPIO() { // DONE

// INPUTS
  for (int i=0; i<8; ++i) { 
    pinMode(pin_PortC[i],INPUT);
    pinMode(pin_PortD[i],INPUT);   
   }
  pinMode(pin_Ping  ,INPUT); 
  pinMode(pin_HamRdy,INPUT);
  pinMode(pin_PwrDwn,INPUT); // pinned by 3.3 Zener; if LOW, prepare to power down!

// INTERRUPTS
  fHandlePings = FALSE;
  attachInterrupt(pin_Ping,   ISR_Ping,   FALLING);
  NVIC_SET_PRIORITY(IRQ_PORTE+16, 16); // Jake changed, pin_ping is on port E
  //pingTimer.begin(ISR_Ping, 1000); // Create an interrupt ping with 1000 microsecond interval


// OUTPUTS
  pinMode(pin_NsSel[0] ,OUTPUT);   
  pinMode(pin_NsSel[1] ,OUTPUT);   
  pinMode(pin_NsSel[2] ,OUTPUT);   
//  pinMode(pin_PWM[0]   ,OUTPUT);  
//  pinMode(pin_PWM[1]   ,OUTPUT);  
//  pinMode(pin_PWM[2]   ,OUTPUT);  
  pinMode(pin_Buzzer   ,OUTPUT);  
  pinMode(pin_Dtog     ,OUTPUT);   
  pinMode(pin_Reset    ,OUTPUT);   
  pinMode(pin_HamPwr   ,OUTPUT);   
  pinMode(pin_CAN0_Lo  ,OUTPUT);   
  pinMode(pin_KillMePls,OUTPUT);

// Initial States
  digitalWrite(pin_NsSel[0] ,LOW);  // Initial rate: 1kHz
  digitalWrite(pin_NsSel[1] ,LOW);  // Initial rate: 1kHz
  digitalWrite(pin_NsSel[2] ,LOW);  // Initial rate: 1kHz
//  digitalWrite(pin_PWM[0]   ,LOW);
//  digitalWrite(pin_PWM[1]   ,LOW);
//  digitalWrite(pin_PWM[2]   ,LOW);
  digitalWrite(pin_Buzzer   ,LOW); // Start with counter in reset mode
  digitalWrite(pin_Dtog     ,LOW);  // Count or TimeHi? Start LOW.
  digitalWrite(pin_Reset    ,HIGH); // Start with counter in reset mode
  digitalWrite(pin_HamPwr   ,LOW);  // Start with Ham off; switch High to turn on
  digitalWrite(pin_CAN0_Lo  ,HIGH); // Low power mode == Pin --> VCC
  digitalWrite(pin_KillMePls,LOW);  // Don't tell Cmod to kill me!!
  
  //if (SERIAL_USB) {SERIAL_USB.println(" ");}
  //if (SERIAL_USB) {SERIAL_USB.println("GPIO Ports initialized...  ");}

} // setup_GPIO()

void setup_Interfaces() {  // DONE
// ------------------------------------------------------------ 
//   Start SERIAL_USB, Query data rate, set Ns, and start Hamamatsu
// Jake changed!
  SERIAL_DAT.setTX(pin_Ser1_TX);
  SERIAL_DAT.setRX(pin_Ser1_RX);
  SERIAL_DAT.begin(SERIAL_DAT_BAUD,SERIAL_8N1);
//  SERIAL_USB.begin(115200);
  SERIAL_USB.begin(SERIAL_USB_BAUD);
  if (SERIAL_USB) {SERIAL_USB.println("\n\n\nRAD_Counter_Teensy Reporting for Service.");}

  //while (!SERIAL_USB) { }; //WHAT THE FUCK

// RTC  -- after Serial, before SD
  // set the Time library to use Teensy 3.0's RTC to keep time
  setSyncProvider(getTeensy3Time);
  if (timeStatus()!= timeSet) {
    if (SERIAL_USB) {SERIAL_USB.println("Unable to sync with the RTC");}
  } else {
    if (SERIAL_USB) {SERIAL_USB.println("RTC has set the system time");}
  }
  // Set FS Timestamp callback
  FsDateTime::callback = dateTime;

// I2C0

// SPI1

//  SPI1.setMOSI(pin_SPI1_MOSI);
//  SPI1.setMISO(pin_SPI1_MISO);
//  SPI1.setSCK(pin_SPI1_SCK);
//  //SPI.setCS(pin_SPI1_CS);
//  //pinMode (pin_SPI1_CS, OUTPUT);
//  SPI1.begin();

// CANBUS: Can0 on 29/30

// SD via SdFs

#if !ENABLE_DEDICATED_SPI
  if (SERIAL_USB) {SERIAL_USB.println(F(
    "\nFor best performance edit SdFsConfig.h\n"
    "and set ENABLE_DEDICATED_SPI nonzero")); }
#endif  // !ENABLE_DEDICATED_SPI
  // Initialize SD.
  if (!sd.begin(SD_CONFIG)) {
      if (SERIAL_USB) {SERIAL_USB.println("SD Initialization failed!!");}
//      return(-1);
  }

}

void setup_Sensors() {
// Initialize TMP117 I2C Temperature Sensor
//  if (tempsensor.setupSensor() == true) {
//    SERIALOUT.println("TMP117 set up successfully");
//  }else {
//    SERIALOUT.println("TMP117 failed to set up");
//  }
//
// Initialize ADIS16209 Tilt Sensor
/*
  if (tiltsensor.setupSensor() == true) {
    if (SERIAL_USB) {SERIAL_USB.println("ADIS16209 set up successfully");
  }else{
    if (SERIAL_USB) {SERIAL_USB.println("ADIS16209 failed to set up");
  }
  tiltsensor.transceiveSensor(XINCL_OUT);
  */
//  delayMicroseconds(40);
}

void setup_Timers() { 
    // Initialize DWT CPU-cycle counter, for  use  in timing pings:
  ARM_DEMCR |= ARM_DEMCR_TRCENA;
  ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
}





/*      Count Cycle Functions
 */

int  Open_Files() { // DONE  
  char              Filename_Root[128],//
                    Filename_Time[24],//
                    Filename_Num[16],
                    Filename[128],//
                    Header_Time[24];//
                    
  sprintDateTime(Header_Time,Filename_Time);

  sd.chdir("/");
  sd.mkdir(Filename_Time);
  sd.chdir(Filename_Time);
  
// Build Filename Root
  strcpy(Filename_Root,FILENAME_ROOT);
  strcat(Filename_Root,Filename_Time);
    

// Open & Preallocate Binary Files

  for(int i=0;i<N_FILES;++i) {
    strcpy(Filename,Filename_Root);
    sprintf(Filename_Num,"_f%.2u.bin",i);
    strcat(Filename,Filename_Num);
    if(!DataFile[i].open(Filename, O_WRITE | O_CREAT | O_TRUNC)) { 
      errorHalt(ERR_MSG_FILE_OPEN_FAILED); 
     }
    if(!DataFile[i].preAllocate(PRE_ALLOCATE_MiBS * ONE_MiB))  
      errorHalt(ERR_MSG_FILE_PREALLOC_FAILED);
  }

// Open and Fill Header File

  strcpy(Filename,Filename_Root);
  strcat(Filename,".txt");

  if(!MetaFile.open(Filename, O_RDWR | O_CREAT)) {  errorHalt(ERR_MSG_FILE_OPEN_FAILED); }

  MetaFile.printf(F("* WHOI/MIT Future Ocean Lab Radiometer Data File \r\n"));
  MetaFile.printf(F("*  \r\n"));
  MetaFile.printf("* Ship: %s \r\n",ThisDive_ShipName);
  MetaFile.printf("* Cruise: %s \r\n",ThisDive_CruiseName);
  MetaFile.printf("* Radiometer: %s \r\n",ThisDive_RadName);
  MetaFile.printf("* Software Version: %f \r\n",FOL_RAD_VV);
  MetaFile.printf(F("*  \r\n"));
  MetaFile.printf("* Dive Message: %s \r\n",ThisDive_Header_Msg);
  MetaFile.printf(F("*  \r\n"));
  MetaFile.printf("* File Created at: %s \r\n",Header_Time);
  MetaFile.printf(F("*  \r\n"));
  MetaFile.printf("* Sampling Rate (Hz): %u \r\n",Ns[ThisDive_SampleRateCode]);
  MetaFile.printf(F("*  \r\n"));
  MetaFile.printf(F("* Each Ping generates an 8B binary Data Packet: \r\n"));
  MetaFile.printf(F("*    [2B] 0xFC00 <-- Token indicating Data Packet  \r\n"));
  MetaFile.printf(F("*    [2B] <Microseconds since last ping>  \r\n"));
  MetaFile.printf(F("*    [2B] <Pulse Count>  \r\n"));
  MetaFile.printf(F("*    [2B] <TimeHi mod 16>  \r\n"));
  MetaFile.printf(F("*  \r\n"));
  MetaFile.printf(F("* A 1Hz Heartbeat is stored in two 8B Packets: \r\n"));
  MetaFile.printf(F("*    [2B] 0xFD00 <-- Token indicating Heartbeat Packet A \r\n"));
  MetaFile.printf(F("*    [2B] <X_Inclination>  \r\n"));
  MetaFile.printf(F("*    [4B] <UTC seconds> \r\n"));
  MetaFile.printf(F("*    [2B] 0xFE00 <-- Token indicating Heartbeat Packet A \r\n"));
  MetaFile.printf(F("*    [2B] <Y_Inclination>  \r\n"));
  MetaFile.printf(F("*    [4B] <UTC microseconds>  \r\n"));
  MetaFile.printf(F("*  \r\n"));
  MetaFile.printf(F("*  \r\n"));
  MetaFile.flush();

  if (SERIAL_USB) {SERIAL_USB.println();}
  if (SERIAL_USB) {SERIAL_USB.println(F("Files opened and preallocated...  "));}

  return 0;
}

void Start_Count() { // DONE
  if (SERIAL_USB) {SERIAL_USB.println(" ");}

  // Startup Hamamatsu
  digitalWrite(pin_HamPwr,HIGH);
  if (SERIAL_USB) {SERIAL_USB.println();}
  if (SERIAL_USB) {SERIAL_USB.println(F("Hamamatsu Powered Up... "));}

  // Start Counting
  digitalWrite(pin_Reset,LOW);
  if (SERIAL_USB) {SERIAL_USB.println();}
  if (SERIAL_USB) {SERIAL_USB.println(F("Fabric Counters Running... "));}
  
  // Start Ping Interrupt
  fHandlePings = TRUE;
  if (SERIAL_USB) {SERIAL_USB.println();}
  if (SERIAL_USB) {SERIAL_USB.println(F("Photon counting has begun!"));}
  if (SERIAL_USB) {SERIAL_USB.println();}

  fStopCount = FALSE;
  
}

void Log_Data() {
  
  static int            Count=0,        // Result of Write_Ring_to_SD()
                        eval=0,
                        HamWasRdy=3,    // Start high to trigger opening "not ready" msg
                        HamIsRdy=0;
  static bool           fHeartbeat_Local=LOW;
  static uint32_t       LS_uSecs_Local,
                        LS_Pulses_Local,
                        LS_TimeHi_Local;
  static double         LS_Secs, LS_PercentHi;


  while(fStopCount == FALSE) {
    
    /*  1. If there's an RU+ in the cache, log to SD  
    */
    
    noInterrupts();
    Count = hTeensyRing->Count ;
    interrupts();
    if(Count > SIZE_RU) {
      if( (eval = Write_Ring_to_SD()) != 0) {
        if(eval == ERR_FILE_WRITE_FAILED) {
          /*  TODO: panic, file write failed*/
          if (SERIAL_USB) {SERIAL_USB.println("File Write Failed! Shutting Down!");}
          fStopCount = TRUE;
          }
        else if(eval == ERR_OUT_OF_FILES) {
            /* TODO:  OUT OF FILES! Hold Ints, ADD MORE FILES, 
                      EAT THE LOST DATA FOR A BIT, restore Ints*/
          if (SERIAL_USB) {SERIAL_USB.println("File Write Failed! Shutting Down!");}
          fStopCount = TRUE;
        }  
      }
    }
    
    /*  2. Check for Heartbeat: Serial out, Query Sensors     
    */
    // Essential to pause interrupts here -- we could easily collide with a 
    // write to fHeartbeat in the PING ISR. Don't let it happen!
    noInterrupts();
    fHeartbeat_Local = fHeartbeat;
    interrupts();
    
    if(fHeartbeat_Local==HIGH) {

      // NOTE: It's tempting to protect LastSec_* from race conditions, as
      // ISR_PING might interrupt and change them midswing.  However, we only 
      // get to this code if the heartbeat was recently called.  A collision 
      // thus requires 1s latency -- if that happens, we have other problems!

//      noInterrupts();
      fHeartbeat = LOW;
      LS_uSecs_Local    = LastSec_uSecs;
      LS_Pulses_Local   = LastSec_Pulses;
      LS_TimeHi_Local   = LastSec_TimeHi;
//      interrupts();
      
      LS_Secs      =  1.0 * LS_uSecs_Local  / 1000000.0;
      LS_PercentHi = 16.0 * LS_TimeHi_Local /   10000000.0;
      
      if (SERIAL_USB) {SERIAL_USB.println("  ");
      SERIAL_USB.print(" Secs:   "); SERIAL_USB.println((double)LS_Secs,3); // In Seconds
      SERIAL_USB.print(" Pulses: "); SERIAL_USB.println((uint32_t)LastSec_Pulses); // In number
      SERIAL_USB.print(" TimeHi: "); SERIAL_USB.println((double)LS_PercentHi,3);} // In %

#ifdef HEARTBEAT_TO_METAFILE
      MetaFile.printf("UTC: %u, Secs: %f.3, Pulses: %u, TimeHi: %f.3 \r\n",now(),LS_Secs,LS_Pulses_Local,LS_PercentHi);
#endif      

      // Check for change of HamRdy signal once per Heartbeat
      HamIsRdy = digitalRead(pin_HamRdy);
      if (HamIsRdy!=HamWasRdy) {
        if(HamIsRdy == 1) {if (SERIAL_USB) {SERIAL_USB.println(); SERIAL_USB.println(F(" Hamamatsu Ready! "));}}
        else              {if (SERIAL_USB) {SERIAL_USB.println(); SERIAL_USB.println(F(" Hamamatsu On Standby... "));}};
        HamWasRdy = HamIsRdy;
      } // if (HamIsRdy!=HamWasRdy)

      // Pull New Tilt Data
      // 2B X_Inclination, Request Y Inclination for next read
     // New_Tilt[0] = tiltsensor.transceiveSensor(YINCL_OUT);
      // Wait for ADIS registers to stabilize -- Doesn't block interrupts!!
      //delayMicroseconds(40);
      // 2B X_Inclination, Request Y Inclination for next read
      //New_Tilt[1] = tiltsensor.transceiveSensor(XINCL_OUT);
      
    } // if(fHeartbeat==HIGH)



    // ------------------------------------------------------------ 
    //  3. Check PwrDown Pin
    eval = digitalRead(pin_PwrDwn);
    if(eval==LOW) {
      fStopCount    = TRUE;
      fPowerDownNow = TRUE;
    }
    
  } // while(fStopCount == FALSE)
}

void Stop_Count() {

  fStopCount = TRUE;

  // Start Ping Interrupt
  fHandlePings = FALSE;
  if (SERIAL_USB) {SERIAL_USB.println(); 
  SERIAL_USB.println(F("Photon counting has stopped. "));}
  
  digitalWrite(pin_Reset,HIGH);
  if (SERIAL_USB) {SERIAL_USB.println();
  SERIAL_USB.println(F("Fabric Counters Zeroed... "));}

  digitalWrite(pin_HamPwr,LOW);
  if (SERIAL_USB) {SERIAL_USB.println();
  SERIAL_USB.println(F("Hamamatsu Powered Down... "));}

}

void Close_Files() {
  char              FileNameTime[24],
                    HeaderTime[24];
                    
  sprintDateTime(HeaderTime,FileNameTime);
    
  MetaFile.printf("* File Closed at %s \r\n",HeaderTime);
  MetaFile.flush();
  MetaFile.truncate();
  MetaFile.close();
    
  for(int j=0;j<N_FILES;++j) {
    DataFile[j].flush();
    DataFile[j].truncate();
    if(DataFile[j].fileSize()==0) {DataFile[j].remove();};
    DataFile[j].close();
  }

  sd.chdir("/");

  if (SERIAL_USB) {SERIAL_USB.println();
  SERIAL_USB.println(F(" Files Closed! "));}
  
}





/*    Interrupt Routine
*/

FASTRUN void ISR_Ping(void) { // DONE
/*    ISR_Ping: respond to ping by reading data and storing to RingBuffer
   
x         Record new ping time
x         Write 2B us-since-last-ping into local buffer
x         Set Dtog High
x         Read 16-bit bus into local buffer
x         Set Dtog Low
x         Read 16-bit bus into local buffer
x         Push local buffer into RingBuffer for SD writes
x         If new Payload is available (sensor data, etc) push to RingBuffer
x         Incriment Per-msec and Per-sec counts
x         If 50ms of Pings have gone by,
x             write serial data header
x         If 1ms of Pings have gone by,
x             calculate extended counts from per-msec counts and timehi
x             log-scale extended counts to uint16_t
x             write serial log-scaled extended counts
x         Decriment Ping_Count
x         If 1s of Pings have gone by, 
x             add UTC to UTC_buffer:
x             Ping_Count = Ns;
x             Write local buffer into global read buffer
x             Write serial heartbeat

------------------------------------------------------------------------------*/
  // Buffers for SD data
  static uint8_t    SD_Data_Buffer8[SD_DATA_BUFFER_BYTES];
  static uint16_t*  SD_Data_Buffer16 = (uint16_t*) SD_Data_Buffer8;
  static uint8_t    SD_Heart_Buffer8[SD_HEART_BUFFER_BYTES];
  static uint16_t*  SD_Heart_Buffer16 = (uint16_t*) SD_Heart_Buffer8; 
  static uint32_t*  SD_Heart_Buffer32 = (uint32_t*) SD_Heart_Buffer8; 
  // Buffers for Serial Data
  static uint8_t    Serial_Data_Header8[SERIAL_BUFFER_DHEAD_BYTES];
  static uint16_t*  Serial_Data_Header16 = (uint16_t*) Serial_Data_Header8;
  static uint32_t*  Serial_Data_Header32 = (uint32_t*) Serial_Data_Header8;
  static uint8_t    Serial_Data_Buffer8[SERIAL_BUFFER_DATA_BYTES];
  static uint16_t*  Serial_Data_Buffer16 = (uint16_t*) Serial_Data_Buffer8;
  static uint8_t    Serial_Heart_Buffer8[SERIAL_BUFFER_HEART_BYTES]; // TODO: Create Union so we can pack in float
  static uint16_t*  Serial_Heart_Buffer16 = (uint16_t*) Serial_Heart_Buffer8;
  static uint32_t*  Serial_Heart_Buffer32 = (uint32_t*) Serial_Heart_Buffer8;
  // Multi-ping accumulators
  static uint32_t   accum_hb_uSecs=0,accum_hb_TimeHi=0,accum_hb_Pulses=0,accum_hb_Photons=0; // Pulses and Duty over last Sec for heartbeat
  static uint32_t   accum_ms_TimeHi=0,accum_ms_Pulses=0,accum_ms_Photons=0; //Pulses and Duty over last ms for serial data
  // Intermediate calculations
  static uint8_t    linlogscale_photons_per_ms8[2];   
  static uint16_t*  linlogscale_photons_per_ms16 = (uint16_t*) linlogscale_photons_per_ms8; //Logscale of photons_per_ms
  static const float      logscale_constant = exp2f(16)/log10f(MAX_COUNTS_PER_MS);
  // Time and counters
  static uint32_t   ISR_Now;
  static uint32_t   ISR_Millis;
  static uint16_t   PingCount = Ns[ThisDive_SampleRateCode];
  static uint16_t   PingsPerMs = 1;
  static uint16_t   SerialWordCountdown = 0;
  static uint32_t   CPU_cycles = 0,
                    CPU_cycles_last = 0;
  // Profiler and debugvariables
  #if PROFILER_ENABLE  
    static uint32_t   profile_cycles_ISR = 0,profile_cycles_LOG10 = 0;
    static uint32_t   profile_CPU_logstart;
  #endif
  #if EMULATOR_ENABLE
    static uint32_t   fakeCount=0;
  #endif
  
  if(fHandlePings==TRUE) {
    /*    0. Suspend Interrupts and check time
*/
    noInterrupts();    
    CPU_cycles = ARM_DWT_CYCCNT; // Use free-running DWT cpu-click-counter on the K77 M4...
    ISR_Now = now();
    ISR_Millis = millis();

/*    1. PULL DATA FROM CMOD
 Data Packet Format [8B]:
    [2B] TOKEN_DATA
    [2B] uint16_t time since last ping in usec
    [2B] uint16_t Pulses
    [2B] uint16_t TimeHi
 */
    SD_Data_Buffer16[0] = SD_TOKEN_DATA;
    SD_Data_Buffer16[1] = (uint16_t) round((CPU_cycles - CPU_cycles_last)/cpu_clicks_per_us); // us between pings, up to 65ms
    CPU_cycles_last = CPU_cycles;
    
//          Set Dtog High and read 16-bit bus into local buffer
    SD_Data_Buffer8[4] = (uint8_t) (GPIOC_PDIR & 0xFF); // ~20ns
    SD_Data_Buffer8[5] = (uint8_t) (GPIOD_PDIR & 0xFF); // ~20ns
//          Set Dtog Low and read 16-bit bus into local buffer
    digitalWriteFast(pin_Dtog,LOW);
    while(ARM_DWT_CYCCNT <= CPU_cycles_last + DTOG_cycles_delay) {};
    delayMicroseconds(1);
    SD_Data_Buffer8[6] = (uint8_t) (GPIOC_PDIR & 0xFF); // ~20ns
    SD_Data_Buffer8[7] = (uint8_t) (GPIOD_PDIR & 0xFF); // ~20ns
    digitalWriteFast(pin_Dtog,HIGH);

// In emulator mode, replace read with ping count
    #if EMULATOR_ENABLE
      SD_Data_Buffer16[2] = fakeCount;
      SD_Data_Buffer16[3] = fakeCount;
    #endif

//          Push local buffer into RingBuffer
    Write_Data_to_Ring(SD_Data_Buffer8,SD_DATA_BUFFER_BYTES);


/*    2. Increment multi-ping accumulators
 */       
    accum_hb_uSecs  += SD_Data_Buffer16[1];
    
    accum_hb_TimeHi += SD_Data_Buffer16[2];
    accum_ms_TimeHi += SD_Data_Buffer16[2];
    
    accum_hb_Pulses += SD_Data_Buffer16[3];
    accum_ms_Pulses += SD_Data_Buffer16[3];


/*    3. If 50 ms gone by, write serial data header (and reset profiler variables) 
*/
    if (SerialWordCountdown == 0) {
      //if (SERIAL_USB) {SERIAL_USB.println("Data header");
      Serial_Data_Header32[0] = SERIAL_TOKEN_DATA;
      #if PROFILER_ENABLE 
        Serial_Data_Header32[1] = profile_cycles_ISR;
        Serial_Data_Header32[2] = profile_cycles_LOG10;
        profile_cycles_ISR = profile_cycles_LOG10 = 0;
      #else
        Serial_Data_Header32[1] = ISR_Now;
        Serial_Data_Header32[2] = ISR_Millis;
      #endif
      SerialWordCountdown = SERIAL_DATA_TOKEN_INTERVAL;
      SERIAL_DAT.write(Serial_Data_Header8,SERIAL_BUFFER_DHEAD_BYTES);
  }

/*    4. If 1 ms gone by, write serial data
    Fit estimated photons from counts and time hi
    Calculate log scale 
    Write Serial
    Iterate countdown and Reset accumulators
 */
    if (PingsPerMs ==1 || (PingCount % PingsPerMs == 1)) {
      //if (SERIAL_USB) {SERIAL_USB.println("Data");
      accum_ms_Photons = Photon_Estimator(accum_ms_Pulses, accum_ms_TimeHi, 3);

      accum_hb_Photons += accum_ms_Photons;
      
      #if PROFILER_ENABLE
        profile_CPU_logstart = ARM_DWT_CYCCNT; //
      #endif

      if (accum_ms_Photons < LOG_CROSSOVER) {
        linlogscale_photons_per_ms16[0] = (uint16_t) accum_ms_Photons;
      }
      else {
        linlogscale_photons_per_ms16[0] = (uint16_t) lroundf(logscale_constant * log10f(accum_ms_Photons));
      }
      #if PROFILER_ENABLE
        profile_cycles_LOG10 += ARM_DWT_CYCCNT - profile_CPU_logstart; //ifdef onl when profiling
      #endif
      SERIAL_DAT.write(linlogscale_photons_per_ms8,2);
      accum_ms_Pulses = accum_ms_TimeHi = 0;
      SerialWordCountdown--;
      #if EMULATOR_ENABLE
        fakeCount++;
      #endif
  }
      

/*    5. Heartbeat: WRITE 1s MARKER TO SD AND TRIGGER SERIAL HEARTBEAT

   
 */       
    if(--PingCount == 0) {
      if (SERIAL_USB) {SERIAL_USB.println("Heartbeat");}
      
      PingCount = Ns[ThisDive_SampleRateCode];

      /* SD Heartbeat Format [16B]:
   [2B] 0xFDFD 
   [2B] uint16_t X_Tilt
   [4B] uint32_t UTC Seconds
   [2B] 0xFEFE
   [2B] uint16_t Y_Tilt
   [4B] uint32_t UTC Microseconds
       */
      SD_Heart_Buffer16[0] = SD_TOKEN_HEART_A;
      SD_Heart_Buffer16[1] = New_Tilt[0];
      SD_Heart_Buffer32[1] = ISR_Now;
      SD_Heart_Buffer16[4] = SD_TOKEN_HEART_B;
      SD_Heart_Buffer16[5] = New_Tilt[1];
      SD_Heart_Buffer32[3] = ISR_Millis;
      Write_Data_to_Ring(SD_Heart_Buffer8, SD_HEART_BUFFER_BYTES);

      /*  Serial Heartbeat Format [32B]:
0   [4B] 0x81118111 
1   [4B] uint32_t UTC Seconds
2   [4B] uint32_t UTC Millisedconds
3   [4B] uint32_t Pulses last sec
4   [4B] uint32_t TimeHi last sec
5   [4B] uint32_t Photons last sec
6   [2B] uint16_t X_Tilt
6.5 [2B] uint16_t Y_Tilt
7   [4B] 0x81118111
       */
      Serial_Heart_Buffer32[0]  = SERIAL_TOKEN_HEART;
      Serial_Heart_Buffer32[1]  = ISR_Now;
      Serial_Heart_Buffer32[2]  = ISR_Millis;
      Serial_Heart_Buffer32[3]  = accum_hb_Pulses; 
      Serial_Heart_Buffer32[4]  = accum_hb_TimeHi;
      Serial_Heart_Buffer32[5]  = accum_hb_Photons;
      Serial_Heart_Buffer16[12] = New_Tilt[0];
      Serial_Heart_Buffer16[13] = New_Tilt[1];
      Serial_Heart_Buffer32[7]  = SERIAL_TOKEN_HEART;
      
      LastSec_uSecs  = accum_hb_uSecs;
      LastSec_Pulses = accum_hb_Pulses;
      LastSec_TimeHi = accum_hb_TimeHi;
      LastSec_Photons = Photon_Estimator(accum_hb_Pulses, accum_hb_TimeHi, 0);
      
      accum_hb_uSecs = accum_hb_Pulses = accum_hb_TimeHi = accum_hb_Photons = 0;
      
      SERIAL_DAT.write(Serial_Heart_Buffer8, SERIAL_BUFFER_HEART_BYTES);
      
      fHeartbeat = HIGH;
    } // if(--PingCount == 0)
    
#if PROFILER_ENABLE
    profile_cycles_ISR += ARM_DWT_CYCCNT - CPU_cycles; //ifdef profiler
#endif
    interrupts();
  } // if(fHandlePings==TRUE)
  else {
    PingCount = Ns[ThisDive_SampleRateCode];
    PingsPerMs = PingCount/1000;
    SerialWordCountdown = 0;
    accum_hb_uSecs=accum_hb_TimeHi=accum_hb_Pulses=0; 
    accum_ms_TimeHi=accum_ms_Pulses=0;
    #if EMULATOR_ENABLE
      fakeCount = 0;    
    #endif
  }


}


/*    Shutdown Routine
*/
void Shutdown() {  // Done-ish
  if (SERIAL_USB) {SERIAL_USB.println();
  SERIAL_USB.println(F(
    "Are you sure you want to sut down the Teensy?\r\n"
    "Turning back on requires a physical power cycle.\r\n"
    "Type 'Y' to continue...\r\n"));}

  while (!SERIAL_USB.available()) {yield();}
  if (SERIAL_USB.read() != 'Y') {
    if (SERIAL_USB) {SERIAL_USB.println(F("Exiting, 'Y' not typed."));}
    return;
  }
  
  if (SERIAL_USB) {SERIAL_USB.println("OK, Shutting Teensy down!!");}
  digitalWrite(pin_HamPwr,LOW);
  delayMicroseconds(50);
  digitalWrite(pin_KillMePls,HIGH);  // Tell Cmod to kill me!!
  BuzzerShutdown();
  while(1) {};
} // setup_Shutdown()

void setup() { // DONE 
  delay(100);
  setup_GPIO();
  setup_Interfaces();
  setup_Sensors();
  setup_Timers();
  BuzzerHamOpen();
} // Setup()


void loop() { // DONE
  Open_Files();
  Start_Count();
  Log_Data();
  Stop_Count();
  Close_Files();     
  while(TRUE) {};
}
