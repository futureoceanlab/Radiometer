/*------------------------------------------------------------------------------ 

     Rad_Teensy
 
------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------ 

     Allan Adams
     - Future Ocean Lab
       Massachusetts Institute of Technology
     - Deep Submergence Lab, AOPE
       Woods Hole Oceanographic Institute
 
------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------ 
 
 RAD_Teensy is a Teensy 3.6 executable that operates the FOL/WHOI Radiometer.
 Its key responsibilities are:
 
 1. Capture & timestamp raw photon counts at 1-32kHz from the Hamamatsu sensor
    via the Cmod A7 based "A"FE over Ports C and D, plus I2C & SPI sensor data
 2. Store data to non-volatile storage (SD card)
 3. Provide serial interface for control and heartbeat
 4. Don't fuck up
 
 In a little more detail.....
 
 A. The Hamamatsu & Xilinx front end:
 
 Our sensor, a Hamamatsu C13366-1350GD, outputs digital signals over SMB of
 duration 20ns and amplitude ~3.7V. More precisely, there is a 40% chance 
 (quantum efficiency 0.4) that any single photon hitting the sensor will trigger 
 a geiger-mode voltage spike of Raleigh-ish form (a sudden rise and a gradual 
 fall-off) out of the raw sensor.  The Hamamatsu module feeds this raw signal 
 to a fast comparator which filters this complex pulse into a clean square 
 pulse about 20ns wide with rise and fall times of under 2ns.  We can thus 
 measure the incident photon flux by counting pulses in the output of the 
 comparator and multitplying by 2.5 to account for the missed 60% of photons.

 Two effects limit the linearity of this signal.  First, as with any geiger-
 mode device, there is an irreducible dark noise due to spontaneous 
 excitationt of the high-gain sensor.  On this device that dark rate is about 
 1000 counts per second (1k cps), corresponding to about 2,500 would-be photons 
 per second (2.5k pps).  Empirically, this noise floor is extremely stable: on
 the two devices tested in our lab, the mean dark count was about 990 cps 
 with a standard deviation of about 40cps.  That  means we can meaningfully 
 infer photon flux from comparator counts down to around 40cps ~ 100 pps.

 The second failure of linearity arises at the high-luminosity regime, and is 
 considerably more problematic.  Suppose a second photon hits an independent 
 pixel on our sensor while the output of the first photon is still high.  The 
 output of the spad-array is the sum of the voltages generated by each pixel, 
 so the input to the coparator now  sees a  signal that is up to twice as 
 high and lasts up to twice as long as that produced by a single photon.  
 Correspondingly, the digital output from the comparator is a pulse that lasts
 up to twice as long, but with the same height.  If we simply count pulses, 
 then, that second photon is lost, leading to a departure from linearity that 
 grows rapidly as the typical photon arrival time decreases: as we ramp up 
 the incident photon flux, such photon "collisions" become more and more 
 common and the nuber of pulses lags further and further behind the true flux. 
 This effect starts to become important around 1M cps and O(15%) by 10M cps.
 At sufficiently high flux (~25M cps), adding another photon is more likely 
 to create a collision than a new pulse -- *increasing* the incident flux
 thus actually *decreases* the number of pulses coming out of the comparator. 
 Eventually the sensor fully saturates (~50MHz), with all pixels constantly 
 triggered and the comparator permanently high.

 On paper, that's annoying: the map between pulse count and infered photon 
 flux is doubly-valued, meaning we  need to be careful to stay (well) within
 the almost-linear low-flux regime to be able to reliably infer the incident 
 fluxes. In the ocean, unfortuantely, that's just not possible: thanks to 
 all sorts of optical "noise" in the ocean (I'm looking at you, biolumin-
 escent squid) it's easy for the incident flux to  pop over the maximum of 
 that curve and ruin any chance we have of nailing down the ambient flux.

 The answer is inescapable: it's not enough to just count pulses, we need to 
 duration of the pulses too.  More generously,  we need a  good  coordinate 
 near the  maximum of the count curve.  This turns out to be non-trivial. 

 The approach we have taken is somewhat brute-force: rather than detect 
 rising edges in the comparator output, we sample the comparator at very 
 high frequency (480 or 960 MHz), allowing us to both count pulses (which 
 provides a good coordinate in the linear regimes at both high and low 
 luminosity) as well as the fraction of the time that the output is high. 
 Fortunately the precise timing of individual collisions doesn't matter, 
 just the statistics, which makes the data problem easy enough to handle 
 with a small FPGA (doing the high-speed sampleing and counting) and 
 microcontroller (sampling the FPGA counts at low speed and storing to
 disk).  Concretetly, we use:
 
    * a Cmod A7 breakout for the Xilinx Artix-7 FPGA running at 240MHz 
      and sampling the comparator output via 2- or 4-bit SERDES inputs, 
      sampling that datastream to count pulses and time spent high, then
      storing the results in fast counters whose values it outputs over
      16-bit bus (GPIO pins) at 1 to 32 kHz to:
      
    * a Teensy 3.6 also running at 240MHz that reads the two 16-bit data
      streams into a circular FIFO buffer which is subsequently written 
      to SD in the background.  The Teensy also handles sensors, Serial 
      comms, and general system control.

 The upshot is that we can infer from these two data streams (pulses, 
 fraction high) the incident photon flux to within a few percent or 
 better over fluxes ranging  from ~50 cps to ~50M cps, or six decades 
 of dynamic range.  That's pretty good.

 
 Before getting into the Teensy code, let's review the Cmod's interface.
 The Cmod has the folloiwing pins wired to the Teensy:
      -- in
    DATA_OUT[16]   Cmod-->Teensy   16-bit data bus (8 Port C, 8  Port D)
    PING_OUT       Cmod-->Teensy   Falling edge == new data available
      -- out
    DTOG_IN        Teensy-->Cmod   H: Data = Pulses;  L: Data = Time High
    NS_SEL_IN[3]   Teensy-->Cmod   Select sampling rate (1-32kHz)


-------------------------------------------------------------------------------- 

 B.  Data Rates:

 The Cmod is sending two 16-bit samples with every ping.  Pings arrive with a 
 frequency of 1, 2, 4, 8, 10, 16, 24, 32 kHz (user selected).  Each ping is 
 stored along with the elapsed time since previous ping (2B) for a total of 6B 
 per ping.  That
 gives the following table  of  data rates:
       kHz    kB/s     MB/hr     GB/day
       1         6      21.6       0.518
       2        12      43.2       1.04
       4        24      86.4       2.07
       8        48     172.8       4.14
       10       60     216.0       5.18
       16       96     345.6       8.29
       24      144     518.4      12.44
       32      192     691.2      16.59
 Note that this does not include any additional payload (sensor data and UTC 
 recorded a few times per second) so this is a minor undercount by < 1%.  Said 
 more succinctly, tthe rates of interest lie within these ranges:

    6 to 192 kB/s      22 to 691 MB/hr     0.5 to 17 GB/day 

 We could, of course, sample faster if there's a scientific reason to do so.
 The fundamental speed limitation here is how precisely we can do the sampling
 timing, but pushing up to 64kHz should be doable.  
 
 By default we'll sample at 10kHz, giving us a default data rate of about 
 
       60 Kb/s            216 MB/hr          5.18 GB/day
 
 In  the scope of things, that's a leisurely data rate for an SD card -- the 
 SD interface we're using can handle 18MB/s; we are well within envelope! That 
 said, the SD interface presents some latency challenges for memory-limited MCUs, 
 so we do have work to do.  To start, SD writes happen in large blocksizes -- 
 strictly in multiples of 512b, but usually in much larger chunks, with RUs of 
 16KiB, 32KiB, or even larger.  To avoid SD interface latencies slowing
 things down, we store data into a large ring buffer, writing RUs to disk as
 soon as enough data are stored. 

 The size of the RingBuffer is constrained by several things:
      Data rates can be up to 192kB/s
      SD Latency can be up to 500ms
      T3.6 has 256kB RAM
      RU size = 16KiB
  We skin this cat with a RingBuffer of 12*16kB = 6*32kB = 192kB, leaving 64kB 
  free for program and SD libraries to do their thing while providing between 
  1s and 32s of latency buffer. If that's not enough, we have other problems.



-------------------------------------------------------------------------------- 


 C.  Sensors:
 
BEGIN   OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD  
 
 On top of the counting photons, we need to keep track of which way the system
 is pointing.  To that end we have a precision Tilt sensor, the Honeywell
 HMC6343, on a Sparkfun breakout, accessible via I2C.  We can be pretty casual
 about  precisely  when  we  query, as the tilt should not be changing all
 that fast,
 
 The computational job that remains is to sample the 16-bit latch at 12kHz into
 a data buffer (FAST), store the buffer to non-volatile storage (LAZY), update
 the Tilt-sensor data (also LAZY), and provide Comms (async serial during
 runtime, wifi on deck to pull data) to manage the circus (SLOW). This is well
 within the scope of a headless 4-core RPi3A+ with RT-patched kernel.  We
 implement the counter, latch, SMB, and power electronics and connectors as a
 custom hat on the Pi. Note that we need 12GPIO pins for the data, 2 for LE &
 CLR, 2 for I2C (tilt), and 1 last pin for the Hamamtsu status line, for a
 total of 17GPIO lines.
 
 A note on power.  The radiometer will be fed 12V (up to 20W), but the Pi needs
 5V and the Hamamtsu needs +5V and -5V.   We handle the conversions with a set
 of three LMR12020's, an extremely high-efficiency (>95%) switching-mode buck
 chipset, producing 5V, 5.5V, and -5.5V. The 5V feeds the Pi/hat while the
 +/-5.5V feed a pair of LDOs to generate very low noise +/-5V rails for the
 Hamamatsu. This brings our overall system efficiency down to about 90%.  Total
 power draw should hover somewhere under 6W nominal, with bursts up to perhaps
 10W when all hell breaks loose. :-)
 
END   OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD  
 

 
 
 -------------------------------------------------------------------------------- 


 D.  Formatting and Protocols
 
 Metadata File Header Format  (ASCII):
 "Future Ocean Lab Radiometer Data File \r\n"
 "Software Version: FOL_RAD_VV"
 " .....\r\n"
 "Data Rate: SAMPLES_PER_SEC  \r\n"
 "Data Block Size: 4096  \r\n"
 "Data Format: Microseconds [2B] Photon  Count [2B]   \r\n"
 "Data Header Size: 32B  \r\n"
 "Data Header Format: \"@@...(18 times)...@@\" EpochTime[4B] NanoSeconds[4B] Tilt[6B] \r\n"
 " .....\r\n"
 "CRUISE NAME, SHIP NAME, etc \r\n"
 "YYYY:MM:DD HH:MM:SS \r\n"
 
 
 Data Chunk Header Format (binary):
 "@@...(18 times)...@@" EpochTimeUTC[4B] NanoSeconds[4B] Tilt[6B]
 32 Bytes [= 18+14]
 
 Data Point Format:
 [2B: uint16_t time since last measurement in usec] [2B: padded 12bit photon count]
 4 Bytes
 
 Heartbeat Message Format
 “RAD.VV yyyy:mm:dd  hh:mm:ssZ DDDDDDDDDD HHHHH PPPPP RRRRR \r\n"
 
 
 
 -------------------------------------------------------------------------------- 


 E. Coding
 
 For the most part this is a pretty straightforward coding problem, with two
 caveats.  First, there are multiple timing-critical processes that need to 
 play nicely with each  other:
 
    1. Ping --> Read and store data immediately into RingBuffer
    2. Write logged data to SD
    3. Read from I2C  & SPI  sensors
    4. Serial Heartbeat and CLI

Second, there are multiple resources  with  potential race conditoins:
 
    1. RingBuffer:  
      Write: Ping_ISR
      Read: SD Storage (main loop)

    2. Payload Buffer
      Write: Main Loop
      Read: Ping_ISR
 
 To ensure we never miss a ping, we handle the data reads via a ping-
 triggered interrupt routine. To avoid any race condition over the buffer, 
 we place all writes-to-buffer into the same interrupt routine, and wrap  
 all flag-raising and -lowering with interrupt disables.  Reads from 
 the buffer and writes to the SD are then handled in the main loop with a
 simple semaphore to avoid races. [Note: we use an SD library that handles 
 interruption gracefully.]  Sensor reads and Serial CLI are also handled in 
 the main loop, with Sensor data stored in a global "payload" container 
 that's flagged for storage in the buffer during the next interupt.
 
 
  The job of this code is thus to:

    0. Setup and Initialization
    
      A. Setup GPIO & comms channels
  
      B. Build filestructure: 
        i. Preallocate SD files: 
           1 hour at max 32kHz data rate = 691 MB
           ==> Filesize = 1GB
           Preallocate array of 24 files
        ii. Write global headers  (first 16kB = header)
       
      C. Build ring buffers, initialize related variables

      D. Initiate Interrupt routine PING_ISR waiting on PING_IN
 
    1. PING_ISR: respond to ping by reading data and storing to RingBuffer
    
          Record new ping time
          Set Dtog High
          Decriment Ping_Count
          Read 16-bit businto local buffer
          Set Dtog Low
          Write 2B us-since-last-ping into local buffer
          Read 16-bit bus (8 in PortC, 8 in PortD) into local buffer
          If new payload is available (sensor data, etc) add to local buffer
          If 1s of Pings have gone by, add UTC to local buffer:
               4B ASCII @@??
               4B UTC
               4B ElapsedMillis
               4B ASCII ??@@
               Ping_Count = Ns;
          Write local buffer into global read buffer

    3. In main loop:
          If an RU of data are abaiable in the Ring buffer, write 1RU to SD
          If Sensor data are stale (.1-1Hz), update sensor data & store in 
            payload, taking care to prevent races over flags or pointers.
          Check for Serial IO and process expeditiously.


 */



/*------------------------------------------------------------------------------ 

    Header Files

------------------------------------------------------------------------------*/


#include "SdFs.h"
#include "FreeStack.h"









/*------------------------------------------------------------------------------ 

    Global DEFINEs

------------------------------------------------------------------------------*/

// RingBuffer definitions
//#define SIZE_RU 32768
//#define N_BUFS 6
#define SIZE_RU 16384
#define N_BUFS 12

// SD  Definitions
// Use FIFO SDIO.
#define SD_CONFIG SdioConfig(FIFO_SDIO)

// File Definitions
#define N_Files 24
#define File_Length 1073741824

// Possible sampling rates:
#define Ns_0   1000
#define Ns_1   2000
#define Ns_2   4000
#define Ns_3   8000
#define Ns_4  10000
#define Ns_5  16000
#define Ns_6  24000
#define Ns_7  32000
              
// Selected Sampling Rate
#define Ns_Sel 0




/*------------------------------------------------------------------------------ 

    Glocabl Variables: Pins

------------------------------------------------------------------------------*/

// INPUT PINS
const byte pin_PortC[]  = {15, 22, 23, 9, 10, 13, 11, 12};  // Byte 1
const byte pin_PortD[]  = { 2, 14,  7, 8,  6, 20, 21,  5};  // Byte 2
const byte pin_Ping     =  34; // Data redy at falling edge
const byte pin_TSleep   =  39; //
const byte pin_HamRdy   =   3; //

// Output Pins
const byte pin_NsSel[]  = {16,17,18}; // 24, 25, 28?
const byte pin_PWM[]    = {36,37,38}; // One of these is gone, one will be tthe power-down signal
const byte pin_PwrDwn   =  35; // Low:Power is going down in 10s, burn the files and save the cannolli
const byte pin_Dtog     =  33; // Low to request Pulse count, High to request Cycle count
const byte pin_HamPwr   =  4;  // Enable power to the Hamamatsu Load Switch

// COMMS PINS
const byte pin_I2C_SDA    = 18; // SDA
const byte pin_I2C_SCL    = 19; // SCL 

const byte pin_Serial1_TX = 26; // TX
const byte pin_Serial1_RX = 27; // RX 

const byte pin_CANBUS_TX  = 29; // TX
const byte pin_CANBUS_RX  = 30; // RX 

const byte pin_SPI_MOSI   =  1; // MOSI 
const byte pin_SPI_MISO   =  0; // MISO
const byte pin_SPI_CS     = 31; // CS
const byte pin_SPI_SCK    = 32; // SCK



/*------------------------------------------------------------------------------ 

    Glocabl Variables: Files and Buffers

------------------------------------------------------------------------------*/


// Preallocate 1GiB files.
const uint64_t PRE_ALLOCATE_SIZE = File_Length;

SdExFat sd;
ExFile file[N_Files];
char FileName[N_Files];
int CurrentFile = 0;

volatile uint8_t Payload[8];
volatile size_t  PayloadSize=0;


elapsedMillis    MillisElapsed;
static uint8_t   UTC_Buffer[16];
char             UTC_Buffer_Head[] = "@@??"; 
char             UTC_Buffer_Tail[] = "??@@"; 






/*------------------------------------------------------------------------------ 

    RingBuffer structure and functions

------------------------------------------------------------------------------*/

typedef struct {
    uint8_t * const _ring;
    size_t Head;  
    size_t Tail;
    volatile size_t Count;
    const size_t Size;
} t_RingBuffer;

typedef t_RingBuffer* hRingBuffer;

#define MAKE_RING_BUFFER(x,y)           \
    uint8_t x##_data_space[y];          \
    t_RingBuffer x = {                  \
        ._ring = x##_data_space,        \
        .Head = 0,                      \
        .Tail = 0,                      \
        .Count = 0,                     \
        .Size = y                 \
    }
// MAKE_RING_BUFFER(my_ring_buffer, 32);

// SD card Recording Unit
const size_t size_Ring = N_BUFS * SIZE_RU;

MAKE_RING_BUFFER(TeensyRing, size_Ring);


/*------------------------------------------------------------------------------ 

    Ring_Push  :  Inserts data into the Ring
    
------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------ 
    Along the way it checks for 2 edge cases:
        A. Ring Full 
            ==> returns -1
        B. Data will wrap to or past the end of the Ring
            ==> splits data into chunks and writtes across the divide.

      Note: assume Ring_Push will run inside an interrupt routine
      
------------------------------------------------------------------------------*/

int Ring_Push(hRingBuffer Ring, uint8_t *data, uint8_t data_len) {
  static size_t next,nibbleA,nibbleB;
  
  if(Ring->Count + data_len > Ring->Size) // Not enough room to store data!
    {return(-1);} 
  else 
    {Ring->Count += data_len;} // Once stored, count is  increased to reflect new data.
   
  next = Ring->Head + data_len;  // next is where head will point to after this write.
  
  if (next < Ring->Size) { // if next is inside ring, just do it
    memcpy(Ring->_ring + Ring->Head, data, data_length);
    Ring->Head = next;
  }
  else {// if next is outside ring, need to break up data chunk and write across modulo:
    nibbleA = Ring->Size - Ring->Head; // Data slots remaining at end of buffer
    nibbleB = data_len - nibbleA; // Length of leftover data to push into begining of buffer
    memcpy(Ring->_ring + Ring->Head, data, nibbleA);
    if(nibbleB>0) memcpy(Ring->_ring, data + nibbleA, nibbleB);
    Ring->Head = nibbleB;
  }
  return 0;  // return success to indicate successful push.
}






/*------------------------------------------------------------------------------ 

    Serial structure and functions

------------------------------------------------------------------------------*/

void waitSerial(const char* msg) {
  do {
    delay(10);
  } while (Serial.read() >= 0);
  Serial.println(msg);
  while (!Serial.available()) {
    yield();
  }
  Serial.println();
}





/*------------------------------------------------------------------------------ 

    Setup and Initialization

------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------ 
    
      A. Setup GPIO & comms channels
  
      B. Build filestructure: 
        i. Preallocate SD files: 
           1 hour at max 32kHz data rate = 691 MB
           ==> Filesize = 1GB
           Preallocate array of 24 files
        ii. Write global headers  (first 16kB = header)
       
      C. Build ring buffers, initialize related variables

      D. Initiate Interrupt routine PING_ISR waiting on PING_IN
     

------------------------------------------------------------------------------*/


void setup() {

// ----------------------------------------------------------------------------
//  Setup GPIO & comms channels

// GPIO

  for (int i=0; i<8; i++) { pinMode(pin_PortC[i],INPUT); } ;
  for (int i=0; i<8; i++) { pinMode(pin_PortD[i],INPUT); } ;
  pinMode(pin_Ping  ,INPUT); 
  pinMode(pin_TSleep,INPUT);
  pinMode(pin_HamRdy,INPUT);

  for (int i=0; i<2; i++) { pinMode(pin_NsSel[i],OUTPUT); } ;
  for (int i=0; i<3; i++) { pinMode(pin_PWM[i]  ,OUTPUT); } ;
  pinMode(pin_Dtog    ,OUTPUT);
  pinMode(pin_HamPwr  ,OUTPUT);

  digitalWrite(pin_Dtog,LOW);
  digitalWrite(pin_NsSel[0],LOW);
  digitalWrite(pin_NsSel[1],LOW);
  digitalWrite(pin_NsSel[2],LOW);
//  digitalWrite(pin_PWM[0],LOW);
//  digitalWrite(pin_PWM[1],LOW);
//  digitalWrite(pin_PWM[2],LOW);
//  digitalWrite(pin_PWM[3],LOW);


// I2C

// SPI

//  SPI.setMOSI(pin_SPI_MOSI);
//  SPI.setMISO(pin_SPI_MISO);
//  SPI.setSCK( pin_SPI_SCK);
//  pinMode (pin_SPI_CS, OUTPUT);
//  SPI.begin();

// CANBUS: Can0 on 29/30
// Can0.begin();



// ------------------------------------------------------------ 
//  Build filestructure: 
//        i. Preallocate SD files: 
//           1 hour at max 32kHz data rate = 691 MB
//           ==> Filesize = 1GB
//           Preallocate array of 24 files
//        ii. Write global headers  (first 16kB = header)
//

  for (int i=0;i<N_Files;i++) {
    if (!file[i].open(FileName[i], O_CREAT | O_TRUNC |O_RDWR)) {
      sd.errorHalt("file.open failed",);
    }
    if (!file[i].preAllocate(PRE_ALLOCATE_SIZE)) {
      sd.errorHalt("file.preAllocate failed");    
    }
  }

  // WRITE HEADERS





// ------------------------------------------------------------ 
//   Build ring buffers, initialize related variables
//

  MillisElapsed(0);
  memcpy(UTC_Buffer   ,UTC_Buffer_Head,4);
  memcpy(UTC_Buffer+12,UTC_Buffer_Tail,4);



// ------------------------------------------------------------ 
//   Start Serial, Query data rate, set Ns, and start Hamamatsu
//

  Serial1.setTX(pin_Serial1_TX);
  Serial1.setRX(pin_Serial1_RX);
  Serial1.begin(115200,SERIAL_8N1);
  Serial1.println("RAD_Counter_Teensy Reporting for Service");
  
  while (!Serial) {
    yield();
  }
  waitSerial("Select Sampling Rate (0-7)");

  digitalWrite(pin_NsSel[0],( (Ns_Choice >> 0)  & 0x01  ? HIGH : LOW));
  digitalWrite(pin_NsSel[1],( (Ns_Choice >> 1)  & 0x01  ? HIGH : LOW));
  digitalWrite(pin_NsSel[2],( (Ns_Choice >> 2)  & 0x01  ? HIGH : LOW));
  Serial.print("Ring Dimension = ");
  Serial.println(size_Ring);
  Serial.print("FreeStack: ");
  Serial.println(FreeStack());


// Startup Hamamatsu
  digitalWrite(pin_HamPwr,HIGH);


// ------------------------------------------------------------ 
//    Initiate Interrupt routine PING_ISR waiting on PING_IN
//
  attachInterrupt(pin_Ping, ISR_Ping, FALLING);

// LET'S GO!!!

} // Setup()




/*------------------------------------------------------------------------------ 

    ISR_Ping : Ping interrupt routine

------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------ 

    ISR_Ping: respond to ping by reading data and storing to RingBuffer
    
x         Record new ping time
x         Set Dtog High
          Decriment Ping_Count
x         Read 16-bit bus into local buffer
x         Set Dtog Low
x         Write 2B us-since-last-ping into local buffer
x         Read 16-bit bus into local buffer
x         Push local buffer into RingBuffer
x         If new payload is available (sensor data, etc) push to RingBuffer
          If 1s of Pings have gone by, add UTC to local buffer:
               6B ASCII @@@@
               6B UTC+2B(ms)
               Ping_Count = Ns;
          Write local buffer into global read buffer

------------------------------------------------------------------------------*/

FASTRUN void ISR_Ping(void) {
  static uint16_t NewData[3];
  static uint32_t _Pulses_=0,_Duty=0; // Pulses and Duty over last Sec
  static uint32_t _tmptime[2];
  static elapsedmicros Ping_uclock;
  static uint16_t NewPingTime = 0,
                  OldPingTime = 0,
                  PingCount   = 0;
  
  noInterrupts();

//          Record new ping time
   NewPingTime = Ping_uclock;

//          Set Dtog High
    digitalWriteFast(pin_Dtog,HIGH);

//          Read 16-bit bus into local buffer
    (uint8_t* NewData)[0] = GPIOC_PDIR & 0xFF; // ~20ns
    (uint8_t* NewData)[1] = GPIOD_PDIR & 0xFF; // ~20ns

//          Set Dtog Low
    digitalWriteFast(pin_Dtog,LOW);

//          Read 16-bit bus into local buffer
    (uint8_t* NewData)[2] = GPIOC_PDIR & 0xFF; // ~20ns
    (uint8_t* NewData)[3] = GPIOD_PDIR & 0xFF; // ~20ns

//          Write 2B us-since-last-ping into local buffer
    Newdata[3]  = NewPingTime - OldPingTime;
    OldPingTime = NewPingTime;
    
//          Push local buffer into RingBuffer
    Ring_Push(NewData,6);

//          Incrementt per-second counters
    _Pulses += NewData[0];
    _TimeHi += NewData[1];
    
//          If new payload is available (sensor data, etc) push to RingBuffer
    if(fNewPayload == TRUE) {
      Ring_Push(NewPayload,PayloadSize);
      fNewPayload = FALSE;
    }

//          If 1s of Pings have gone by, add UTC to local buffer:
    if(--PingCount == 0) {
//               Ping_Count = Ns;
      Ping_Count = Pings_Per_Sec;
//               4B UTC
//               4B ElapsedMillis
      _tmptime[0] = now();
      _tmptime[1] = MillisElapsed();
      memcpy(UTC_Buffer+4,_tmptime,8);
//               Write to RingBuffer
      Ring_Push(UTC_Buffer,16);
      Pulses_LastSec = _Pulses;
      TimeHi_LastSec = _TimeHi;
      _Pulses = _TimeHi = 0;
      fHeartBeat = HIGH;
    }


  
  interrupts();
}
 





void loop() {

  while() {
    
  // ------------------------------------------------------------ 
  //  Query Sensors
  //
  
  // ------------------------------------------------------------ 
  //  Log Data
  //

  if(Ring->Count >= SIZE_RU) {
    if (file.write(Ring->_ring + Ring->tail, SIZE_RU) != SIZE_RU) {
        Serial.println("file.write failed");
        file.close();
        return(-1);
      }
    noInterrupts();
    Ring->Count -= SIZE_RU;
    interrupts();
    Ring->tail = (Ring->tail + SIZE_RU) % Ring->buf_length;
  }
  
  // ------------------------------------------------------------ 
  //  Heartbeat
  //

  if(fHeartbeat==HIGH) {
    cli();
    fHeartbeat=LOW;    
    sei();
    // Beat the Heart
    Serial.print(" Pulses: ");
    Serial.println((uint32_t)Pulses_LastSec);
    Serial.print(" TimeHi: ");
    Serial.println((uint32_t)TimeHi_LastSec);
  }

  // ------------------------------------------------------------ 
  //  Serial CLI
  //


  }  // while()
  
  if (!file.truncate()) {
    sd.errorHalt("truncate failed");
  }

}
