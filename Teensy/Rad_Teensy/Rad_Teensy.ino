/*   MIT Future Ocean Lab  &&  WHOI Deep Submergence Lab
--------------------------------------------------------------------------------
 Project:       FOL Radiometer
 Version:       Beebe
 Design:        RAD_Teensy
 Substrate:     Teensy 3.6
--------------------------------------------------------------------------------
 Module:        RAD_Teensy
 Filename:      RAD_Teensy.iso
 Created:       26/10/2019
 Author:        Allan Adams <awa@mit.edu>
--------------------------------------------------------------------------------
 Description:   RAD_Teensy is a Teensy 3.6 executable that operates the FOL/WHOI 
                Radiometer.  Its key responsibilities are:
 
 1. Capture & timestamp raw photon counts at 1-32kHz from the Hamamatsu sensor
    via the Cmod A7 Front End over Ports C and D, plus I2C & SPI sensor data
 2. Store data to non-volatile storage (SD card)
 3. Provide serial interface for control and heartbeat
 4. Don't fuck up
 
 In a little more detail.....

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
   A. The Hamamatsu & Xilinx front end:

 The FOL/DSL Radiometer is designed to count photons throughout the first 800m
 of the open ocean.  At its heart is an array of geiger-mode photo-diodes 
 capable of resolving individual photon hits with great precision. 
 
 The sensor, a Hamamatsu C13366-1350GD, outputs digital signals over SMB of
 duration 20ns and amplitude ~3.7V. More precisely, there is a 40% chance 
 (quantum efficiency 0.4) that any single photon hitting the sensor will trigger 
 a geiger-mode voltage spike of Raleigh-ish form (a sudden rise and a gradual 
 fall-off) out of the raw sensor.  The Hamamatsu module feeds this raw signal 
 to a fast comparator which filters this complex pulse into a clean square 
 pulse about 20ns wide with rise and fall times of under 2ns.  We can thus 
 measure the incident photon flux by counting pulses in the output of the 
 comparator and multitplying by 2.5 to account for the missed 60% of photons.

 Two effects limit the linearity of this signal.  First, as with any geiger-
 mode device, there is an irreducible dark noise due to spontaneous 
 excitationt of the high-gain sensor.  On this device that dark rate is about 
 1000 counts per second (1k cps), corresponding to about 2,500 would-be photons 
 per second (2.5k pps).  Empirically, this noise floor is extremely stable: on
 the two devices tested in our lab, the mean dark count was about 990 cps 
 with a standard deviation of about 40cps.  That  means we can meaningfully 
 infer photon flux from comparator counts down to around 40cps ~ 100 pps.

 The second failure of linearity arises at the high-luminosity regime, and is 
 considerably more problematic.  Suppose a second photon hits an independent 
 pixel on our sensor while the output of the first photon is still high.  The 
 output of the spad-array is the sum of the voltages generated by each pixel, 
 so the input to the coparator now  sees a  signal that is up to twice as 
 high and lasts up to twice as long as that produced by a single photon.  
 Correspondingly, the digital output from the comparator is a pulse that lasts
 up to twice as long, but with the same height.  If we simply count pulses, 
 then, that second photon is lost, leading to a departure from linearity that 
 grows rapidly as the typical photon arrival time decreases: as we ramp up 
 the incident photon flux, such photon "collisions" become more and more 
 common and the nuber of pulses lags further and further behind the true flux. 
 This effect starts to become important around 1M cps and O(15%) by 10M cps.
 At sufficiently high flux (~25M cps), adding another photon is more likely 
 to create a collision than a new pulse -- *increasing* the incident flux
 thus actually *decreases* the number of pulses coming out of the comparator. 
 Eventually the sensor fully saturates (~50MHz), with all pixels constantly 
 triggered and the comparator permanently high.

 On paper, that's annoying: the map between pulse count and infered photon 
 flux is doubly-valued, meaning we  need to be careful to stay (well) within
 the almost-linear low-flux regime to be able to reliably infer the incident 
 fluxes. In the ocean, unfortuantely, that's just not possible: thanks to 
 all sorts of optical "noise" in the ocean (I'm looking at you, biolumin-
 escent squid) it's easy for the incident flux to  pop over the maximum of 
 that curve and ruin any chance we have of nailing down the ambient flux.

 The answer is inescapable: it's not enough to just count pulses, we need to 
 duration of the pulses too.  More generously,  we need a  good  coordinate 
 near the  maximum of the count curve.  This turns out to be non-trivial. 

 The approach we have taken is somewhat brute-force: rather than detect 
 rising edges in the comparator output, we sample the comparator at very 
 high frequency (480 or 960 MHz), allowing us to both count pulses (which 
 provides a good coordinate in the linear regimes at both high and low 
 luminosity) as well as the fraction of the time that the output is high. 
 Fortunately the precise timing of individual collisions doesn't matter, 
 just the statistics, which makes the data problem easy enough to handle 
 with a small FPGA (doing the high-speed sampleing and counting) and 
 microcontroller (sampling the FPGA counts at low speed and storing to
 disk).  Concretetly, we use:
 
    * a Cmod A7 breakout for the Xilinx Artix-7 FPGA running at 240MHz 
      and sampling the comparator output via 2- or 4-bit SERDES inputs, 
      sampling that datastream to count pulses and time spent high, then
      storing the results in fast counters whose values it outputs over
      16-bit bus (GPIO pins) at 1 to 32 kHz to:
      
    * a Teensy 3.6 also running at 240MHz that reads the two 16-bit data
      streams into a circular FIFO buffer which is subsequently written 
      to SD in the background.  The Teensy also handles sensors, Serial 
      comms, and general system control.

 The upshot is that we can infer from these two data streams (pulses, 
 fraction high) the incident photon flux to within a few percent or 
 better over fluxes ranging  from ~50 cps to ~50M cps, or six decades 
 of dynamic range.  That's pretty good.

 
 Before getting into the Teensy code, let's review the Cmod's interface.
 The Cmod has the folloiwing pins wired to the Teensy:
      -- in
    DATA_OUT[16]   Cmod-->Teensy   16-bit data bus (8 Port C, 8  Port D)
    PING_OUT       Cmod-->Teensy   Falling edge == new data available
      -- out
    DTOG_IN        Teensy-->Cmod   H: Data = Pulses;  L: Data = Time High
    NS_SEL_IN[3]   Teensy-->Cmod   Select sampling rate (1-32kHz)


 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   B.  Data Rates:

 The Cmod is sending two 16-bit samples with every ping.  Pings arrive with a 
 frequency of 1, 2, 4, 8, 10, 16, 24, 32 kHz (user selected).  Each ping is 
 stored along with the elapsed time since previous ping (2B) for a total of 6B 
 per ping.  That gives the following table of data rates:
       kHz    kB/s     MB/hr     GB/day
       1         6      21.6       0.518
       2        12      43.2       1.04
       4        24      86.4       2.07
       8        48     172.8       4.14
       10       60     216.0       5.18
       16       96     345.6       8.29
       24      144     518.4      12.44
       32      192     691.2      16.59
 Note that this does not include any additional payload (sensor data and UTC 
 recorded a few times per second) so this is a minor undercount by < 1%.  Said 
 more succinctly, tthe rates of interest lie within these ranges:

    6 to 192 kB/s      22 to 691 MB/hr     0.5 to 17 GB/day 

 We could, of course, sample faster if there's a scientific reason to do so.
 The fundamental speed limitation here is how precisely we can do the sampling
 timing, but pushing up to 64kHz should be doable.  
 
 By default we'll sample at 10kHz, giving us a default data rate of about 
 
       60 Kb/s            216 MB/hr          5.18 GB/day
 
 In  the scope of things, that's a leisurely data rate for an SD card -- the 
 SD interface we're using can handle 18MB/s; we are well within envelope! That 
 said, the SD interface presents some latency challenges for memory-limited MCUs, 
 so we do have work to do.  To start, SD writes happen in large blocksizes -- 
 strictly in multiples of 512b, but usually in much larger chunks, with RUs of 
 16KiB, 32KiB, or even larger.  To avoid SD interface latencies slowing
 things down, we store data into a large ring buffer, writing RUs to disk as
 soon as enough data are stored. 

 The size of the RingBuffer is constrained by several things:
      Data rates can be up to 192kB/s
      SD Latency can be up to 500ms
      T3.6 has 256kB RAM
      RU size = 16KiB
  We skin this cat with a RingBuffer of 12*16kB = 6*32kB = 192kB, leaving 64kB 
  free for program and SD libraries to do their thing while providing between 
  1s and 32s of latency buffer. If that's not enough, we have other problems.



 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

  C.  Sensors:
 
 On top of the counting photons, we need to keep track of which way the system
 is pointing.  To that end we have a Tilt sensor accessible via SPI.  We can be 
 pretty casual about precisely when we query, as the tilt should not be changing 
 all that fast.

 We also have a handful of sensors accessible over I2C (T, P, ...).  Again, 
 speed is not of the essence, and we can query  them at our leisure.
 

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   D.  Power and Statup / Shutdown Sequences:
 
 A note on power. The main PCB (Teensy, Cmod, etc) operate on a nominal 5V bus,
 but the Hamamatsu needs stable +5 and -5 rails.  Meanwhile the system will be
 fed with anything between 9 and 36V, with no guarantee that noise will be low.
 We handle these conversions with a set of three LMR12020's, an extremely high-
 efficiency (>95%) switching-mode buck chipset, producing 5V, 5.5V, and -5.5V. 
 The 5V feeds the main Cmod/Teensy board, while the +/-5.5V feed a pair of LDOs 
 to generate very low noise +/-5V rails for the Hamamatsu. This brings our 
 overall system efficiency down to about 90%.  

 To provide power, the radiometer carries four 3.7V 18650 cells internally and 
 is able to accept 9-36V over the SubConn bulkhead.  The load switches from one
 to the other automatically as power is plugged in etc via a small power board, 
 allowing us to keep the system running from the lab to the vehicle -- helpful
 when running in untethered mode.

 Startup is delicate.  The FPGA cannott accept voltage on its pins while it's 
 powered down, so we must turn it on first before turning on anything else --  
 the Teensy, the Hamamatsu, etc.  Ditto  on powerdown. To deal with this, both
 the Teensy and the Hamamatsu draw power from independent load switches. Once 
 the Cmod is ready it enables the Teensy load switch;  when the Teensy is ready 
 it enables the Hamamatsu load switch.  

 Shutting down is more complex.  The shutdown is initiated by shorting two pins 
 on the connector.  This (a) puls a pin low on the Teensy and (b) gives a 10s
 time window for everything to shutdown gracefully.  The Teensy then terminates
 its loops, saves files, disables the Hamamatsu load switch,  and then shuts 
 itself down.  When the powerbus hits the end of the grace period, the bus is 
 pulled low, shutting  down the Cmod gracefully.
 
 Here's a short rundown of the voltage  and power demands of each  device:

    Device          Vin     Amax      Atyp      Wmax      Wtyp
                        V    mA        mA        mW        mW
    Hamamatsu       +5      1000      200       5000      1000
                    -5        60       40        300       200      
    Cmod A7         +5       200       40       1000       200
    Teensy          +5       240      120       1200       600
    Motherboard     +5       100       40        500       200
----------------------------------------------------------------------
    Total                   1600      440       8000      2200

 Total power draw should thus hover somewhere around 2.2W, with bursts up to 
 perhaps 6W during startup, shutdown, or acts of Cthulu.
 
 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

 E.  Formatting and Protocols
 
 Metadata File Header Format  (ASCII):
 "Future Ocean Lab Radiometer Data File \r\n"
 "Software Version: FOL_RAD_VV"
 " .....\r\n"
 "Data Rate: SAMPLES_PER_SEC  \r\n"
 "Data Block Size: 4096  \r\n"
 "Data Format: Microseconds [2B] Photon  Count [2B]   \r\n"
 "Data Header Size: 32B  \r\n"
 "Data Header Format: \"@@...(18 times)...@@\" EpochTime[4B] \
                                  NanoSeconds[4B] Tilt[6B] \r\n"
 " .....\r\n"
 "CRUISE NAME, SHIP NAME, etc \r\n"
 "YYYY:MM:DD HH:MM:SS \r\n"
 
 
 Data Chunk Header Format (binary):
 "@@...(18 times)...@@" EpochTimeUTC[4B] NanoSeconds[4B] Tilt[6B]
 32 Bytes [= 18+14]
 
 Data Point Format:
 [2B: uint16_t time since last ping in usec] 
 [2B: uint16_t Pulses]
 [2B: uint16_t TimeHi]
 6 Bytes
 
 Heartbeat Message Format
 â€œRAD.VV yyyy:mm:dd  hh:mm:ssZ DDDDDDDDDD HHHHH PPPPP RRRRR \r\n"
 
 
 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

 F. Coding
 
 For the most part this is a pretty straightforward coding problem, with two
 caveats.  First, there are multiple timing-critical processes that need to 
 play nicely with each  other:
 
    1. Ping --> Read and store data immediately into RingBuffer
    2. Write logged data to SD
    3. Read from I2C  & SPI  sensors
    4. Serial Heartbeat and CLI
        Startup choice: Ns or Download? with timeout

 Second, there are multiple resources  with  potential race conditoins:
 
    1. RingBuffer:  
      Write: Ping_ISR
      Read: SD Storage (main loop)

    2. Payload Buffer
      Write: Main Loop
      Read: Ping_ISR
 
 To ensure we never miss a ping, we handle the data reads via a ping-
 triggered interrupt routine. To avoid any race condition over the buffer, 
 we place all writes-to-buffer into the same interrupt routine, and wrap  
 all flag-raising and -lowering with interrupt disables.  Reads from 
 the buffer and writes to the SD are then handled in the main loop with a
 simple semaphore to avoid races. [Note: we use an SD library that handles 
 interruption gracefully.]  Sensor reads and Serial CLI are also handled in 
 the main loop, with Sensor data stored in a global "payload" container 
 that's flagged for storage in the buffer during the next interupt.
 
 
  The job of this code is thus to:

    0. Setup and Initialization
    
      A. Setup GPIO & comms channels
  
      B. Build filestructure: 
        i. Preallocate SD files: 
           1 hour at max 32kHz data rate = 691 MB
           ==> Filesize = 1GB
           Preallocate array of 24 files
        ii. Write global headers  (first 16kB = header)
       
      C. Build ring buffers, initialize related variables

      D. Initiate Interrupt routine PING_ISR waiting on PING_IN
 
    1. PING_ISR: respond to ping by reading data and storing to RingBuffer
    
          Record new ping time
          Set Dtog High
          Read 16-bit businto local buffer
          Set Dtog Low
          Read 16-bit bus (8 in PortC, 8 in PortD) into local buffer
          Write 2B us-since-last-ping into local buffer
          Write local buffer into RingBuffer
          If new payload is available (sensor, etc) write to RingBuffer
            Payload: 12B chunk with !0!0 2B Tilt 2B Incl  !0!0  2B Rot 2B Temp
          Decriment Ping_Count
          If 1s of Pings have gone by, add UTC to local buffer:
               4B ASCII @@??
               4B UTC
               4B ElapsedMillis
               4B ASCII ??@@
               Ping_Count = Ns;
               Write local buffer into RingBuffer

    3. In main loop:
          If an RU of data are abaiable in the Ring buffer, write 1RU to SD
          If Sensor data are stale (.1-1Hz), update sensor data & store in 
            payload, taking care to prevent races over flags or pointers.
          Check for Serial IO and process expeditiously.


  
--------------------------------------------------------------------------------

  Dependencies: 
  
--------------------------------------------------------------------------------

  Issues:
  
------------------------------------------------------------------------------*/
#include "Rad_Teensy.h"

#define CRUISE_NAME "Lindblad / Channel Island, December 2019"
#define SHIP_NAME  "Of Opportunity"
#define RAD_NAME "Statler"
//#define RAD_NAME "Waldorf"


/*    Gloabl Variables: Files and Buffers      
*/

SdFs              sd;                      // 
FsFile            bfile[N_Files];          // 
FsFile            mfile;                   // 

int               CurrentFile = 0;         // 

size_t            RUs_Written = 0;         //
size_t            LastSec_TimeHi=0,        //
                  LastSec_Pulses=0;        // 

//Global Clocks
elapsedMillis     mclock;                  // for ms since last Heartbeat 

// GlobalFlags
volatile int      fHeartbeat    = FALSE;   //
volatile int      fPayload      = FALSE;   //
volatile int      fPowerDownNow = FALSE;   //
volatile int      fStopCount    = TRUE;    //
volatile bool     fHandlePings  = FALSE;   //  In place of dettachInterrupt, set to false
                  

volatile uint8_t  Payload[PAYLOAD_BYTES];            // x
uint8_t           UTC_Buffer[UTC_BUFFER_BYTES];         // x
uint32_t*         UTC_Buffer32   = (uint32_t*) &UTC_Buffer[5]; // 
const size_t      cpu_clicks_per_us =  F_CPU / 1000000;

const size_t      size_Ring = N_BUFS * SIZE_RU;    //
MAKE_RING_BUFFER(TeensyRing, size_Ring);          // 



/*    Read and Write Buffer wrapper functions     
*/

int Write_Ring_to_SD(void) {  // DONE
    if (bfile[CurrentFile].write(TeensyRing._ring + TeensyRing.Tail, SIZE_RU) \
                                                                  != SIZE_RU) {
        Serial.println("file.write failed");
        bfile[CurrentFile].close();
        return(ERR_FILE_WRITE_FAILED);  // if file write fails, panic with -1
    }
    
    noInterrupts();
    TeensyRing.Count -= SIZE_RU;
    TeensyRing.Tail = (TeensyRing.Tail + SIZE_RU) % TeensyRing.Size;
    interrupts();

    if((++RUs_Written) * SIZE_RU >= File_Length) {
      bfile[CurrentFile].close();
      if(++CurrentFile==N_Files) return(ERR_OUT_OF_FILES);
      RUs_Written = 0;
    }
    return(0);
}

int Write_Data_to_Ring(uint8_t *data, uint8_t data_len) {  // DONE
/*------------------------------------------------------------------------------ 

    Write_Data_to_Ring  :  Inserts data into the Ring
    
    Along the way it checks for 2 edge cases:
        A. Ring Full 
            ==> returns -1
        B. Data will wrap to or past the end of the Ring
            ==> splits data into chunks and writtes across the divide.

      Note: assume Write_Data_to_Ring will run inside an interrupt routine
            and can't itself be interrupted
      
------------------------------------------------------------------------------*/
  static size_t next,nibbleA,nibbleB;
  
  if(TeensyRing.Count + data_len > TeensyRing.Size) { // Buffer Full!!
    return(ERR_BUFFER_FULL); 
  } else { TeensyRing.Count += data_len; };
  // Once stored, count is  increased to reflect new data.
   
  // next is where head will point to after this write.
  next = TeensyRing.Head + data_len;  
    
  if (next < TeensyRing.Size) { // if next is inside ring, just do it
    memcpy(TeensyRing._ring + TeensyRing.Head, data, data_len);
    TeensyRing.Head = next;
  } else { // if next is outside ring, need to 
           // break up data chunk and write across modulo:
    // Data slots remaining at end of buffer
    nibbleA = TeensyRing.Size - TeensyRing.Head;
    // Length of leftover data to push into begining of buffer
    nibbleB = data_len - nibbleA;       
    memcpy(TeensyRing._ring + TeensyRing.Head,  data,           nibbleA);
    if(nibbleB>0) memcpy(TeensyRing._ring, data + nibbleA, nibbleB);
    TeensyRing.Head = nibbleB;
  }
  return 0;  // return success to indicate successful push.
}




/*      Helper Functions
 */

void errorHalt(const char* msg) {
  Serial1.print("Error: ");
  Serial1.println(msg);
  if (sd.sdErrorCode()) {
    if (sd.sdErrorCode() == SD_CARD_ERROR_ACMD41) {
      Serial1.println("Try power cycling the SD card.");
    }
    printSdErrorSymbol(&Serial1, sd.sdErrorCode());
    Serial1.print(", ErrorData: 0X");
    Serial1.println(sd.sdErrorData(), HEX);
  }
  while (true) {} 
}

time_t getTeensy3Time() {
  return Teensy3Clock.get();
}

void dateTime(uint16_t* date, uint16_t* time) {
  // Return date using FS_DATE macro to format fields.
  *date = FS_DATE(year(), month(), day());

  // Return time using FS_TIME macro to format fields.
  *time = FS_TIME(hour(), minute(), second());
}

void sprintDateTime(char* sHTime,char* sFNTime) {
  TimeElements tm;
  breakTime(now(),tm);
  
  // "YYYY-MM-DD HH:MM:SS"
  sprintf(sHTime, "%.4u-%.2u-%.2u %.2u:%.2u:%.2u",1970+tm.Year,tm.Month, tm.Day,\
                                                       tm.Hour,tm.Minute,tm.Second);
  // "YYYY_MM_DD__HH_MM_SS"
  sprintf(sFNTime,"%.4u_%.2u_%.2u__%.2u_%.2u_%.2u",1970+tm.Year,tm.Month, tm.Day,\
                                                      tm.Hour,tm.Minute,tm.Second);
}

void Set_Ns(void) {
  digitalWrite(pin_NsSel[0],( (Current_Ns >> 0)  & 0x01  ? HIGH : LOW));
  digitalWrite(pin_NsSel[1],( (Current_Ns >> 1)  & 0x01  ? HIGH : LOW));
  digitalWrite(pin_NsSel[2],( (Current_Ns >> 2)  & 0x01  ? HIGH : LOW));
}



/*      SETUP AND INITIALIZATION FUNCTIONS
 */

void setup_GPIO() { // DONE

// INPUTS
  for (int i=0; i<8; ++i) { 
    pinMode(pin_PortC[i],INPUT);
    pinMode(pin_PortD[i],INPUT);   
   }
  pinMode(pin_Ping  ,INPUT); 
  pinMode(pin_HamRdy,INPUT);
  pinMode(pin_PwrDwn,INPUT); // pinned by 3.3 Zener; if LOW, prepare to power down!

// INTERRUPTS
  fHandlePings = FALSE;
  attachInterrupt(pin_Ping,   ISR_Ping,   FALLING);

// OUTPUTS
  pinMode(pin_NsSel[0] ,OUTPUT);   
  pinMode(pin_NsSel[1] ,OUTPUT);   
  pinMode(pin_NsSel[2] ,OUTPUT);   
//  pinMode(pin_PWM[0]   ,OUTPUT);  
//  pinMode(pin_PWM[1]   ,OUTPUT);  
//  pinMode(pin_PWM[2]   ,OUTPUT);  
  pinMode(pin_Dtog     ,OUTPUT);   
  pinMode(pin_Reset    ,OUTPUT);   
  pinMode(pin_HamPwr   ,OUTPUT);   
  pinMode(pin_CAN0_Lo  ,OUTPUT);   
  pinMode(pin_KillMePls,OUTPUT);

// Initial States
  digitalWrite(pin_NsSel[0] ,LOW);  // Initial rate: 1kHz
  digitalWrite(pin_NsSel[1] ,LOW);  // Initial rate: 1kHz
  digitalWrite(pin_NsSel[2] ,LOW);  // Initial rate: 1kHz
//  digitalWrite(pin_PWM[0]   ,LOW);
//  digitalWrite(pin_PWM[1]   ,LOW);
//  digitalWrite(pin_PWM[2]   ,LOW);
  digitalWrite(pin_Reset    ,HIGH); // Start with counter in reset mode
  digitalWrite(pin_HamPwr   ,LOW);  // Start with Ham off; switch High to turn on
  digitalWrite(pin_Dtog     ,LOW);  // Count or TimeHi? Start LOW.
  digitalWrite(pin_CAN0_Lo  ,HIGH); // Low power mode == Pin --> VCC
  digitalWrite(pin_KillMePls,LOW);  // Don't tell Cmod to kill me!!
  

  Serial1.println(" ");
  Serial1.println("GPIO Ports initialized...  ");

} // setup_GPIO()

void setup_Interfaces() {  // DONE
// ------------------------------------------------------------ 
//   Start Serial1, Query data rate, set Ns, and start Hamamatsu
//

  Serial1.setTX(pin_Ser1_TX);
  Serial1.setRX(pin_Ser1_RX);
  Serial1.begin(115200,SERIAL_8N1);
  Serial1.println("\n\n\nRAD_Counter_Teensy Reporting for Service.");

  while (!Serial1) { };

// RTC  -- after Serial, before SD
  // set the Time library to use Teensy 3.0's RTC to keep time
  setSyncProvider(getTeensy3Time);
  if (timeStatus()!= timeSet) {
    Serial1.println("Unable to sync with the RTC");
  } else {
    Serial1.println("RTC has set the system time");
  }
  // Set FS Timestamp callback
  FsDateTime::callback = dateTime;

// I2C0

// SPI1

// CANBUS: Can0 on 29/30

// SD via SdFs

#if !ENABLE_DEDICATED_SPI
  Serial1.println(F(
    "\nFor best performance edit SdFsConfig.h\n"
    "and set ENABLE_DEDICATED_SPI nonzero")); 
#endif  // !ENABLE_DEDICATED_SPI
  // Initialize SD.
  if (!sd.begin(SD_CONFIG)) {
      Serial1.println("SD Initialization failed!!");
//      return(-1);
  }

}

void setup_Buffers() { // DONE
  for(int i=0;i<12;++i) {
    Payload[i] = 0xFF;
  }
  for(int i=0;i<18;++i) {
    UTC_Buffer[i] = 0xFF;
  }

//  Serial1.println(" ");
//  Serial1.print("Ring Dimension = ");
//  Serial1.println(size_Ring);
//  Serial1.print("FreeStack: ");
//  Serial1.println(FreeStack());

}

void setup_Timers() { 
    // Initialize DWT CPU-cycle counter, for  use  in timing pings:
  ARM_DEMCR |= ARM_DEMCR_TRCENA;
  ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;

}



/*      CLI functions
 */

int  Initial_CLI() {
  uint32_t m;
  char c,ns;

  do { delay(20); } while (Serial1.available() && Serial1.read());
  Serial1.println(" ");
  Serial1.println("Type '1' to log data");
  Serial1.println("     '2' to enter  setup");

  m = micros();
  while (!Serial1.available() && (micros()-m < 30*ONE_MILLION)) {  }
  if(!Serial1.available()) { // Unattended, start logging data at default rate: 
    Current_Ns = 0;
    Set_Ns();
    return(LOG_DATA);
  } 
  // if  we get here, there's  serial data:
  c = Serial1.read();
  
  if (c =='1') {

    do { delay(20); } while (Serial1.available() && Serial1.read());
    Serial1.println(" ");
    Serial1.println("Select Data Sampling Rate:");
    Serial1.println("Type '0' for  1 kHz");
    Serial1.println("Type '1' for  2 kHz");
    Serial1.println("Type '2' for  4 kHz");
    Serial1.println("Type '3' for  8 kHz");
    Serial1.println("Type '4' for 10 kHz");
    Serial1.println("Type '5' for 16 kHz");
//    Serial1.println("Type '6' for 24 kHz"); // 240MHz
//    Serial1.println("Type '7' for 32 kHz"); // 240MHz
    Serial1.println("Type '6' for 25 kHz"); // 250MHz
    Serial1.println("Type '7' for 40 kHz"); // 250MHz

    m =  micros();
    while (!Serial1.available() && (micros()-m < 30*ONE_MILLION)) {  }
    if(!Serial1.available()) { ns = '0';} // No reply, use default rate
    else {ns = Serial1.read();} // Use specified rate
    
    switch(ns)  {
      case '1': Current_Ns = 1; break;
      case '2': Current_Ns = 2; break;
      case '3': Current_Ns = 3; break;
      case '4': Current_Ns = 4; break;
      case '5': Current_Ns = 5; break;
      case '6': Current_Ns = 6; break;
      case '7': Current_Ns = 7; break;
      default:  Current_Ns = 0; break;
    } // Switch(ns)

    Serial1.println(" ");
    Serial1.print("Proceeding with Sampling Rate ");
    Serial1.print(Ns[Current_Ns]);  
    Serial1.println("Hz");

    Set_Ns();
    return(LOG_DATA);    
  }

  // if we get here, go to CLI
  Current_Ns = 0;
  Set_Ns();
  return(RUN_CLI);
}

void Main_CLI() {
  /* Things the user might want to do:
   */  
  /*  USB Pull Data
   *  
   */
  /*  Format SD
   *  
   */
  /*  Change Settings
   *  
   *  
   * 
   */
  
}



/*      Count Cycle Functions
 */

int  Open_Files() { // DONE
/* ------------------------------------------------------------ 
//  Build filestructure: 
//        i. Preallocate SD files: 
//           1 hour at max 32kHz data rate = 691 MB
//           ==> Filesize = 1GB
//           1 day at 10kHz nominal = 5.2GB
//           ==> Preallocate array of 6 files
//        ii. Write global headers  (first 16kB = header)
//
*/
  
  char              Filename_Root[128],
                    Filename_Text[128],
                    Filename_Num[16],
                    Filename[N_Files][128], 
                    FileNameTime[24],
                    HeaderTime[24];
                    
  sprintDateTime(HeaderTime,FileNameTime);


  sd.chdir("/");
  sd.mkdir(FileNameTime);
  sd.chdir(FileNameTime);
  
// Build Filenames
  strcpy(Filename_Root,FILENAME_ROOT);
  strcat(Filename_Root,FileNameTime);
    
  strcpy(Filename_Text,Filename_Root);
  strcat(Filename_Text,".txt");

  for(int i=0;i<N_Files;++i) {
    strcpy(Filename[i],Filename_Root);
    sprintf(Filename_Num,"_f%.2u.bin",i);
    strcat(Filename[i],Filename_Num);
  }


// Open & Preallocate Files

  for(int i=0;i<N_Files;++i) {
    if(!bfile[i].open(Filename[i], O_WRITE | O_CREAT | O_TRUNC)) { 
      errorHalt(ERR_MSG_FILE_OPEN_FAILED); 
     }
    if(!bfile[i].preAllocate(PRE_ALLOCATE_MiBS * ONE_MiB))  
      errorHalt(ERR_MSG_FILE_PREALLOC_FAILED);
  }

// Open and Fill Header File

    if(!mfile.open(Filename_Text, O_RDWR | O_CREAT)) {  errorHalt(ERR_MSG_FILE_OPEN_FAILED); }

    mfile.printf("* Future Ocean Lab Radiometer Data File \r\n");
    mfile.printf("*  \r\n");
    mfile.printf("* Software Version: %f \r\n",FOL_RAD_VV);
    mfile.printf("*  \r\n");
    mfile.printf("* %s, %s \r\n",CRUISE_NAME,SHIP_NAME);
    mfile.printf("*  \r\n");
    mfile.printf("* File Created at %s \r\n",HeaderTime);
    mfile.printf("*  \r\n");
    mfile.printf("* Sampling Rate: 1GHz FPGA subsampled at %uHz\r\n",Ns[Current_Ns]);
    mfile.printf("*  \r\n");
    mfile.printf("* Each Ping generates a 6B binary data packet: \r\n");
    mfile.printf("*    [2B] <Microseconds since last ping>  \r\n");
    mfile.printf("*    [2B] <Pulse Count>  \r\n");
    mfile.printf("*    [2B] <TimeHi mod 16>  \r\n");
    mfile.printf("*  \r\n");
    mfile.printf("* Sensor data is stored asynchronously in  12B packets:  \r\n");
    mfile.printf("*    [2B] 0xFFFF  \r\n");
    mfile.printf("*    [2B] <Tilt1> \r\n");
    mfile.printf("*    [2B] <Tilt2>  \r\n");
    mfile.printf("*    [2B] 0xFFFF   \r\n");
    mfile.printf("*    [2B] <Temp>  \r\n");
    mfile.printf("*    [2B] <Depth> \r\n");
    mfile.printf("*  \r\n");
    mfile.printf("* A 1Hz Heartbeat is stored in a 18B packet as: \r\n");
    mfile.printf("*    [5B] 0xFFFFFFFFFF  \r\n");
    mfile.printf("*    [4B] <UTC seconds> \r\n");
    mfile.printf("*    [4B] <Microseconds>  \r\n");
    mfile.printf("*    [5B] 0xFFFFFFFFFF  \r\n");
    mfile.printf("*  \r\n");
    mfile.printf("*  \r\n");
    mfile.flush();

    Serial1.println(" ");
    Serial1.println("Files opened and preallocated...  ");

    return 0;
}

void Start_Count() { // DONE
  Serial1.println(" ");

  // Startup Hamamatsu
  digitalWrite(pin_HamPwr,HIGH);
  Serial1.println("Hamamatsu Powered Up... ");

  // Start Counting
  digitalWrite(pin_Reset,LOW);
  Serial1.println("Fabric Counters Running... ");
  
  // Start Ping Interrupt
  fHandlePings = TRUE;
  Serial1.println(" ");
  Serial1.println("Photon counting has begun!");
  Serial1.println(" ");

  fStopCount = FALSE;
  
}

void Log_Data() {
  static int Count=0,         // Result of Write_Ring_to_SD()
             eval=0,
             HamWasRdy=1,    // Start high to trigger opening "not ready" msg
             HamIsRdy=1;
  static char cmd;

//  Serial1.print("In Log_Data(), fStopCount = ");
//  Serial1.println(fStopCount);

  while(fStopCount == FALSE) {
    
    // ------------------------------------------------------------ 
    //  1. If there's an RU+ in the cache, log  to SD  
    noInterrupts();
    Count = hTeensyRing->Count ;
    interrupts();
    if(Count > SIZE_RU) {
      if( (eval = Write_Ring_to_SD()) != 0) {
        if(eval == ERR_FILE_WRITE_FAILED) {
          /*  TODO: panic, file write failed*/
          Serial1.println("File Write Failed! Shutting Down!");
          fStopCount = TRUE;
          }
        else if(eval == ERR_OUT_OF_FILES) {
            /* TODO:  OUT OF FILES! Hold Ints, ADD MORE FILES, 
                      EAT THE LOST DATA FOR A BIT, restore Ints*/
          Serial1.println("File Write Failed! Shutting Down!");
          fStopCount = TRUE;
        }  
      }
    } 

    
    // ------------------------------------------------------------ 
    //  2. Query Sensors, Fill Payload                 SKIP for now
    //   

    
    // ------------------------------------------------------------ 
    //  3. Heartbeat      // DONE
    if(fHeartbeat==HIGH) {
      fHeartbeat=LOW;    
      Serial1.print(" Pulses: ");
      Serial1.println((uint32_t)LastSec_Pulses);
      Serial1.print(" TimeHi: ");
      Serial1.println((uint32_t)LastSec_TimeHi);
      
      // Check for change of HamRdy signal once per Heartbeat
      HamIsRdy = digitalRead(pin_HamRdy);
      if (HamIsRdy!=HamWasRdy) {
        if(HamIsRdy == 1) {Serial1.println(" Hamamatsu Ready! ");}
        else              {Serial1.println(" Hamamatsu Warming up... ");};
        HamWasRdy = HamIsRdy;
      } // if (HamIsRdy!=HamWasRdy)
    } // if(fHeartbeat==HIGH)


    // ------------------------------------------------------------ 
    //  4. Minimal Serial CLI 
    if (Serial1.available()) {
      cmd = Serial1.read();
      switch(cmd)  {
        case 'q': 
          Serial1.println(" ");
          Serial1.println(" Stopping count... ");
          Serial1.println(" ");
          fStopCount = TRUE; 
          break;
        default:
          Serial1.println(" ");
          Serial1.println(" Type 'q' to stop count and enter command shell");
          Serial1.println(" ");
          break;
      }
    }


    // ------------------------------------------------------------ 
    //  5. Check PwrDown Pin
    eval = digitalRead(pin_PwrDwn);
//    if(eval==LOW) {
//      fStopCount = TRUE;
//      fPowerDownNow=TRUE;
//    }

    
  } // while(fStopCount == FALSE)
}

void Stop_Count() {

  fStopCount = TRUE;

  // Start Ping Interrupt
  fHandlePings = FALSE;
  Serial1.println(" ");
  Serial1.println("Photon counting has stopped. ");
  Serial1.println(" ");
  
  digitalWrite(pin_Reset,HIGH);
  Serial1.println("Fabric Counters Zeroed... ");

  digitalWrite(pin_HamPwr,LOW);
  Serial1.println("Hamamatsu Powered Down... ");

}

void Close_Files() {
  char              FileNameTime[24],
                    HeaderTime[24];
                    
  sprintDateTime(HeaderTime,FileNameTime);
    
  mfile.printf("* File Closed at %s \r\n",HeaderTime);
  mfile.flush();
  mfile.truncate();
  mfile.close();
    
  for(int j=0;j<N_Files;++j) {
    bfile[j].flush();
    bfile[j].truncate();
    if(bfile[j].fileSize()==0) {bfile[j].remove();};
    bfile[j].close();
  }

  sd.chdir("/");

  Serial1.println(" ");
  Serial1.println(" Files Closed! ");
  
}



/*    Interrupt Routines  
*/

FASTRUN void ISR_Ping(void) { // DONE
/*    ISR_Ping: respond to ping by reading data and storing to RingBuffer
   
x         Record new ping time
x         Write 2B us-since-last-ping into local buffer
x         Set Dtog High
x         Read 16-bit bus into local buffer
x         Set Dtog Low
x         Read 16-bit bus into local buffer
x         Push local buffer into RingBuffer
x         If new Payload is available (sensor data, etc) push to RingBuffer
x         Incriment Per-sec counts
x         Decriment Ping_Count
x         If 1s of Pings have gone by, 
x             add UTC to UTC_buffer:
x             Ping_Count = Ns;
x             Write local buffer into global read buffer

------------------------------------------------------------------------------*/

  static uint8_t   NewData[6];
  static uint16_t* NewData16 = (uint16_t*) NewData;
  static uint32_t  _Pulses=0,_TimeHi=0; // Pulses and Duty over last Sec
  static uint16_t  PingCount   = 0;
  static uint32_t  cycles = 0,
                   cycles_last = 0;

  if(fHandlePings==TRUE) {

/*    0. Suspend Interrupts and check time
*/
    noInterrupts();
    
    cycles = ARM_DWT_CYCCNT; // Use free-running DWT cpu-click-counter on the K77 M4...
    NewData16[0] = (cycles - cycles_last)/cpu_clicks_per_us; // us between pings, up to 65ms
    cycles_last = cycles;
  

/*    1. PULL DATA FROM CMOD
 */
//          Set Dtog High and read 16-bit bus into local buffer
    digitalWriteFast(pin_Dtog,HIGH);
    NewData[2] = GPIOC_PDIR & 0xFF; // ~20ns
    NewData[3] = GPIOD_PDIR & 0xFF; // ~20ns
//          Set Dtog Low and read 16-bit bus into local buffer
    digitalWriteFast(pin_Dtog,LOW);
    NewData[4] = GPIOC_PDIR & 0xFF; // ~20ns
    NewData[5] = GPIOD_PDIR & 0xFF; // ~20ns
//          Push local buffer into RingBuffer
    Write_Data_to_Ring(NewData,6);


/*    2. CATCH AND EXPORT SENSOR PAYLOAD
 */    
    if(fPayload == TRUE) {
      fPayload = FALSE;
      Write_Data_to_Ring((uint8_t *)Payload, PAYLOAD_BYTES);
    } // if(fPayload == TRUE)


/*    3. UPON Ns SAMPLES, WRITE 1s MARKER TO SD AND TRIGGER HEARTBEAT
 */    
//        Increment per-second counters
    _Pulses += NewData[1];
    _TimeHi += NewData[2];
//       Check if it's time for a Heartbeat
    if(--PingCount == 0) {
      PingCount = Ns[Current_Ns];
      UTC_Buffer32[0] = now();
      UTC_Buffer32[1] = mclock;
      Write_Data_to_Ring(UTC_Buffer, UTC_BUFFER_BYTES);
      LastSec_Pulses = _Pulses;
      LastSec_TimeHi = _TimeHi;
      _Pulses = _TimeHi = 0;
      fHeartbeat = HIGH;
    } // if(--PingCount == 0)

    interrupts();
  } // if(fHandlePings==TRUE)
}



/*    System  Shutdown 
*/

void Shutdown() {  // Done-ish
  Serial1.println("Shutting down!!");
  digitalWrite(pin_KillMePls,HIGH);  // Tell Cmod to kill me!!
  while(1) {};
} // setup_Shutdown()

void setup() { // DONE 
  setup_GPIO();
  setup_Interfaces();
  setup_Buffers();
  setup_Timers();
} // Setup()

void loop() { // DONE
  int code = Initial_CLI(); 
  if(code == LOG_DATA) {
    Open_Files();
    Start_Count();
    Log_Data();
    Stop_Count();
    Close_Files();     
    if(fPowerDownNow==TRUE) Shutdown();
  }
  else if(code  == RUN_CLI) {
    Main_CLI();
  }
}
